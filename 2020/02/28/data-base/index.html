<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.png">
	<link rel="shortcut icon" href="/img/logo.png">
	
			    <title>
    Orange's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="orange">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">ORANGE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">创作</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/其他/">其他</a></li><li><a class="category-link" href="/categories/课堂笔记/">课堂笔记</a></li><li><a class="category-link" href="/categories/野生技能/">野生技能</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简介">
		                简介
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="朋友">
		                朋友
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/1170300229" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(/thumbnailImg/data-base.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>数据库课堂笔记Ⅰ</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="数据库课堂笔记Ⅰ"><a href="#数据库课堂笔记Ⅰ" class="headerlink" title="数据库课堂笔记Ⅰ"></a>数据库课堂笔记Ⅰ</h1><h2 id="初步认识数据库系统"><a href="#初步认识数据库系统" class="headerlink" title="初步认识数据库系统"></a>初步认识数据库系统</h2><p>​        <strong>课程简要介绍</strong>。数据库系统组成。从物理上来说有数据库DB，数据库管理系统DBMS，数据库应用程序DBAP，数据库管理员DBA（管理数据库系统），共同组成了数据库系统，分别对应了数据库（表形式等），SQL数据库语言，数据库应用程序，也分别对应了计算机世界，信息世界，现实世界。</p>
<p><img src="/2020/02/28/data-base/image-20200228211010959.png" alt="image-20200228211010959"></p>
<p>​        当前数据库除了有关系数据库，还有面向对象（OO）数据，XML数据库，NoSQL数据库，其他数据库。关系数据库需要考虑<strong>数据库设计</strong>，<strong>数据库应用程序开发</strong>，<strong>数据库存取与控制</strong>。课程特点，抽象，思维，应用，管理，案例。</p>
<p>​        <strong>为什么要学习数据库系统</strong>。现代信息社会需要业务工作和计算机支持，实现积累的效益。大数据时代。数据聚集为数据库，积累成大数据。</p>
<p>​        <strong>什么是数据库</strong>。数据库是相互有关联关系的数据的集合。起源于规范化“表”的处理。E.F.Codd提出了“关系”及关系模型等理论。</p>
<p>​        Table的构成中常用的术语。<strong>数据库就是相互之间有关联的表的集合</strong>。数据库分为结构化数据库和非结构化数据库，结构化数据库有关系数据库，非结构化数据库有工程数据库和图像数据库。</p>
<p><img src="/2020/02/28/data-base/image-20200229221328929.png" alt="image-20200229221328929"></p>
<p>​        <strong>什么是数据库系统</strong>。数据库系统的工作环境（组成）：DB，DBMS，DBAP，DBA，计算机基本系统。例如图书管理数据库系统（实例化和抽象化/概念化）。</p>
<p>​        <strong>什么是数据库管理系统</strong>。从用户角度看数据库管理系统的功能，1.具有数据库定义功能，即DBMS可以提供一套数据定义语言（DDL），2.具有数据库操纵功能（增，删，改，查），DBMS提供数据操纵语言（DML），3.具有数据库控制功能（用户安全策略），DBMS提供数据控制语言（DCL），4.数据库维护功能，DBMS提供一系列程序给用户，用DBA掌控。数据库语言有1.DDL，用户定义数据格式，2.DML，用户对数据进行操作，3.DCL，对数据进行控制，4.数据库各种操作的执行。<strong>前三种组成了SQL（结构化的数据库语言）</strong>。数据库语言与高级语言，一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言（宿主语言）中使用。</p>
<p>​        <strong>什么是数据库管理系统</strong>。强调形式，构造，自动化。从系统角度看DBMS的功能，DBMS为完成DB管理，在后台运行着一系列程序，有编译与执行控制，有查询优化实现，有事物处理，有存储与索引，有（各种）控制程序，某些DBMS系统可越过操作系统直接管理。</p>
<p><img src="/2020/02/28/data-base/image-20200304211931156.png" alt="image-20200304211931156"></p>
<p>​        具体来说有，<strong>语言编译器</strong>，翻译数据库语言的内容成DBMS可执行的命令，如DDL编译器，DML编译器和DCL编译器。<strong>查询优化（执行引擎）与查询实现（基本命令的不同执行算法）</strong>，提高数据库检索速度的手段。<strong>数据存取与索引</strong>，提供数据在磁盘，磁带等上的高效存取手段。<strong>通信控制</strong>，提供网络环境下数据库操作与数据传输的手段。还有事物管理，故障恢复，安全性控制，完整性控制，数据字典管理，API，数据库数据装载，重组等实用程序，数据库性能分析。典型的DBMS，Oracle，DB2（IBM），Sybass，MS SQL Server，MS Access，MS Foxpro。</p>
<p><img src="/2020/02/28/data-base/image-20200304212942373.png" alt="image-20200304212942373"></p>
<p>​        <strong>本课程学什么以及学到什么程度</strong>。用户，应用程序开发员，数据库分析和设计员，DBA，数据库管理系统设计和实现员，特殊和新型数据库管理系统的开发技术。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200304214052503.png" alt="image-20200304214052503"></p>
<h2 id="数据库系统的结构抽象与演变"><a href="#数据库系统的结构抽象与演变" class="headerlink" title="数据库系统的结构抽象与演变"></a>数据库系统的结构抽象与演变</h2><p>​        <strong>本讲学习什么</strong>。数据库的标准模型，数据模型，数据库系统的演变与发展。三级模式，两层映像，物理独立性和逻辑独立性。数据到模式到数据模型。网状/层次模型到关系模型到OO数据模型。</p>
<p>​        <strong>数据库系统的标准结构</strong>。数据库的标准结构就是<strong>三级模式，两层映像</strong>。DBMS管理数据分为三个层次，1.外部层次/用户层次，某一用户能够看到与处理的数据，全局数据中的某一部分，2.全局层次/概念层级/逻辑层次，从全局角度理解/管理的数据，含相应的关联约束（即数据保存形式），3.内部层次/物理层次，存储在介质上的数据，含存储路径，存储方式，索引方式等。</p>
<p><img src="/2020/02/28/data-base/image-20200304215001721.png" alt="image-20200304215001721"></p>
<p>​        数据与数据的结构——模式。模式是数据库中数据数据所进行一种结构性的描述（数据的结构，例如表的属性行）。视图/数据，某一种表现形式下表现出来的数据库中的数据（具体的数据）。三级视图，1.外模式（用户模式）和外部视图（或<strong>简称视图</strong>），某一用户能够看到与处理的数据的结构描述，2.概念模式（全局模式/逻辑模式，或者<strong>简称模式</strong>）和概念视图，从全局角度理解/管理的数据的结构描述，含相应的关联约束，体现在数据之间的内在本质联系，3.内模式（物理模式）和内部视图，存储在介质上的数据的结构描述，含存储路径，存储方式，索引方式等。两层映像，1.E-C Mapping，将外模式映射为概念模式，便于用户观察和使用，2.C-I Mapping，将概念模式映射为内模式，便于计算机进行存储和处理。数据库的标准结构如图。让用户定义模式，DBMS自动实现两层映像。开发是基于外部视图开发。</p>
<p><img src="/2020/02/28/data-base/image-20200304222744745.png" alt="image-20200304222744745"></p>
<p>​        逻辑数据独立性，当概念模式变化时，可以不改变外部模式（只需要改变E-C Mapping），从而无需改变应用程序。物理数据独立性，当内部模式变化时，可以不改变概念模式（秩序改变C-I Mapping），从而不改变外部模式。</p>
<p>​        <strong>什么是数据模型</strong>。数据模型是规定模式统一描述方式的模型，是对模式本身结构的抽象。模式是对数据本身结构形式的抽象（列名及其之间的联系）。例如关系模型：所有模式都可为抽象表（Table）的形式（<strong>数据结构</strong>），而每一个具体的模式都是拥有不同列名的具体的表，对这种表形式的数据有哪些<strong>操作</strong>和<strong>约束</strong>。模式是对数据的结构的抽象，模型是对模式的抽象。</p>
<p><img src="/2020/02/28/data-base/image-20200304224822800.png" alt="image-20200304224822800"></p>
<p>​        三大经典数据模型。1.关系模型，表的形式组织数据，2.层次模型，树的形式组织数据，实体型之间通过系型连接，实体型中的是<strong>记录</strong>，两条记录之间的联系用指针连接，3.网状模型，图的形式组织数据。</p>
<p>​        <strong>数据库系统的演变与发展</strong>。简要发展史，1.数据库技术探索阶段，格式文件系统，2.数据库技术确立阶段，三大数据库，3.数据库技术成熟阶段，标准化数据库系统结构模型，4.数据库技术深化发展阶段，数据库方法理论化。第一个发展，<strong>由文件系统到数据库系统</strong>。文件系统中用户不必考虑文件存储的物理细节，但是数据与程序紧密结合，数据库系统，由DBMS统一存取，维护数据组织形式及语义，可较强地独立于应用程序，数据存取可以以记录为单位，也可以以数据项和记录集合为单位，有统一的数据控制功能，数据共享程度高，整体数据结构化，独立于应用程序的高效率查询/统计操作。第二个发展，<strong>由层次模型数据库，网状模型数据库到关系数据库</strong>。层次模型与网状模型数据库，有指针较复杂（要用户建立），数据检索依赖指针系统指示的路径，逐一记录的操作，不能有效支持记录集合的操作，关系数据库，<strong>消除了指针</strong>，不依赖路径/过程信息，有效支持记录集合的操作，较为完善的理论基础。第三个发展，<strong>由关系数据库到对象关系数据库，面向对象数据库</strong>。关系数据库，需要满足关系的第1范式（对用户不方便，子列名，不确定个数列），有数据项不可再分特性，对象-关系数据库，可有效支持不满足关系第1范式的数据项，以对象来封装需分解的数据项，行对象与列对象，聚集对象（一个集合，多值属性）与结构对象（复合属性对应的），面向对象数据库，支持复杂的数据类型，数据封装和抽象数据结构，支持面向对象的一些特性（类，继承，封装，多态），XML数据库，是数据库的另一种形式（半结构化数据库），数据与数据的语义合并在一起进行存储和处理，面向数据交换而提出。第四个发展，<strong>由多种多样的数据库到多数据库开放式互连</strong>。ODBC（Open DataBase Connection），程序员面对ODBC，ODBC和不同的DBMS交互，还有JDBC。第五个发展，<strong>由普通数据库到与各种先进技术结合所形成的新型数据库</strong>。如OA，Database Machine，Intelligent Database，Distributed Database（DDB），Image Database/Multimedia Database，Temporal Database，Mobile Database，Active Database，Fuzzy Database，Real-Time Database，Engineering Database，Geographical Database，Special Database，Statistical Database，Internet Database，Data Warehouse/Data Mining，NoSQL。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200304232659263.png" alt="image-20200304232659263"></p>
<h2 id="关系模型之基本概念"><a href="#关系模型之基本概念" class="headerlink" title="关系模型之基本概念"></a>关系模型之基本概念</h2><p>​        <strong>本讲学习什么</strong>。关系模型概述，什么是关系，关系模型中的完整性约束。围绕关系的相关概念，如域，笛卡尔积，关系，关系模式，关键字/键/码，外码/外键，主码/主键，主属性与非主属性。三个完整性，实体完整性，参照完整性和用户自定义完整性。</p>
<p>​        <strong>关系模型简述</strong>。关系模型是从表及表的处理方式中抽象出来的，引入集合理论与逻辑学理论，是数据库的三大经典数据模型之一，大多数商品化数据库系统的模型，SQL的基础。一个关系就是一个Table，关系模型由三部分组成，1.描述DB各种数据的<strong>基本结构形式</strong>，2.描述Table与Table之间所可能发生的各种<strong>操作</strong>（关系运算），3.描述这些操作所应遵循的<strong>约束条件</strong>（完整性约束）。</p>
<p><img src="/2020/02/28/data-base/image-20200306223310665.png" alt="image-20200306223310665"></p>
<p>​        关系运算包括关系代数和关系演算，关系演算又包括元组演算和域演算。<strong>关系代数</strong>是基于集合的运算，操作对象都是集合，是一次一集合的操作（非关系型的数据操作通常是一次一记录的操作），基于关系代数设计的数据库语言（ISBL）是用计算机可识别的符号表征关系代数的运算符合。<strong>元组演算</strong>是基于逻辑的运算（与，或，非等），基于元组演算设计的数据库语言，是用计算机可识别的符号表征元组演算的运算符号。<strong>域演算</strong>，基于示例的运算，基于域演算设计的数据库语言，QBE（Query By Example）基于表格填写查询条件来进行表达查询的一种语言。</p>
<p><img src="/2020/02/28/data-base/image-20200306224337275.png" alt="image-20200306224337275"></p>
<p>​        <strong>什么是关系</strong>。域，一组值的集合，这组值有相同的数据类型，集合中的元素个数称为基数。元组，笛卡尔积的每个元素称作一个n-元组。分量，元组$(d_1,d_2,…,d_n)$中的每一个$d_i$叫做一个分量，笛卡尔积的基数就是笛卡尔积的结果集合的大小。<strong>关系，一组域的笛卡尔积的子集（笛卡尔积中具有某一方面意义的那些元组被称作一个关系）</strong>。每一列的名字称为列名（属性名），不同的列可能来自同一域，列值来自域。关系可用$R(A_1:D_1,A_2:D_2,…,A_n:D_n)$表示可以简记为$R(A_1,A_2,…,A_n)$，这种描述又被称为<strong>关系模式</strong>或<strong>表标题</strong>，其中$R$是关系名字，$A_i$是属性，$D_i$是属性所对应的域，$n$是关系的度或者目，关系中元组的数目称为关系的基数。在DBMS中许多域直接说明为属性的类型，长度等（如char(8)等）。同一关系模式下，可有很多的关系，关系模式是关系的结构，关系是关系模式在某一时刻的数据，关系模式是稳定的，而关系是某一时刻的值，是随时间可能变化的。</p>
<p>​        <strong>关系有什么特性</strong>。<strong>列是同质</strong>，即每一列中的分量来自同一域，是统一类型的数据。<strong>不同的列可能来自同一个域</strong>，但是关系模式中的每一个分量必须不同。<strong>列/行位置互换性</strong>，区分哪一列/行是靠列名/某一或某几列的值（关键字/键字/码字）。<strong>关系和表的区别</strong>，关系的任意两个元组不能完全相同，表可能并不完全遵守此特性。<strong>属性不可再分特性</strong>（又称为<strong>关系第一范式</strong>）。</p>
<p><img src="/2020/02/28/data-base/image-20200306233740798.png" alt="image-20200306233740798"></p>
<p>​        <strong>候选码与外码</strong>。<strong>候选码/候选键</strong>，关系中的一个属性组，其值能够唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码，候选码可能有多个。<strong>主码/主键</strong>，当有多个候选码时，可以选定一个作为主码。<strong>主属性与非主属性</strong>，包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性，所有属性构成这个关系的候选码，称为<strong>全码</strong>（<strong>全码关系</strong>）。<strong>外码/外键</strong>，关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码对应，则称这个属性组为R的外码/外键。</p>
<p><img src="/2020/02/28/data-base/image-20200307160610403.png" alt="image-20200307160610403"></p>
<p>​        <strong>关系模型的完整性</strong>。关系模型的完整性有三个，1.<strong>实体完整性</strong>，关系的主码中的属性值不能为空值（即不知道，不存在或无意义的值，因为不能参与算术，比较或逻辑运算）。2.<strong>参照完整性</strong>，如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2中的某个元组的Pk值，或者为空值（意义是如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在）。3.<strong>用户自定义完整性</strong>，用户针对具体的应用环境定义的完整性约束条件（属性值有长度或者范围）。DBMS对关系完整性的支持，实体完整性和参照完整性由DBMS系统自动支持，并且使用户可以自行定义有关的完整性约束条件，当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200307161923115.png" alt="image-20200307161923115"></p>
<h2 id="关系模型值关系代数"><a href="#关系模型值关系代数" class="headerlink" title="关系模型值关系代数"></a>关系模型值关系代数</h2><p>​        <strong>本讲学习什么</strong>。关系代数的基本/扩展操作（并，差，积，选择，投影，更名，交，$\theta$连接，自然连接），关系代数的组合与应用训练，关系代数的复杂扩展操作（除，外连接）。基本思维训练“一个集合，世家一个操作得到一个集合，依次施加关系代数操作，进而得到所需结果”，“以集合为中心“。</p>
<p>​        <strong>关系代数概述</strong>。基于集合，提供了一系列的关系代数操作，并，差，笛卡尔积（广义积），选择，投影和更名等基本操作，交，连接，关系等扩展操作。以一个或多个关系为输入，结果是一个新的关系，具有一定的过程性，是一种抽象语言，是学习其他数据库语言，如SQL等的基础。关系代数操作可以分为1.<strong>集合操作</strong>，并，交，差，笛卡尔积，2.<strong>纯关系操作</strong>，投影，选择，连接，除。为什么要提出关系代数。</p>
<p><img src="/2020/02/28/data-base/image-20200307223208101.png" alt="image-20200307223208101"></p>
<p>​        <strong>并相容性的概念</strong>。并相容性定义，关系R与关系S存在相容性，当且仅当1.关系R和关系S的属性数目必须相同，2.对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域（Domain）相同。</p>
<p>​        <strong>并操作</strong>。并定义，假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作$R\cup S$，它由或者出现在关系R中，或者出现在S中的元组构成。合并时去掉重复元组。</p>
<p>​        <strong>差操作</strong>。差定义，假设关系R和关系S是并相容的，则关系R与关系S的差运算结果也是i一个关系，记作$R-S$，它由出现在关系R中但不出现在关系S中的元组构成。</p>
<p>​        <strong>广义积操作</strong>。广义笛卡尔积定义，关系$R(&lt;a_1,a_2,…,a_n&gt;)$与关系$S(&lt;b_1,b_2,…,b_m&gt;)$的广义笛卡尔积（简称广义积或笛卡尔积）运算结果也是一个关系，记作$R\times S$，它由关系R中的元组与关系S的元组进行所有可能值的拼接（或串接）构成。$R\times S=S\times R$，因为行/列无关性。两个关系R和S，他们的属性个数分别为n和m（R是n度关系，S是m度关系），则笛卡尔积属性个数是$n+m$，他们的元组个数分别为x和y（关系R的基数x，S的基数y），则笛卡尔积元组个数是$xy$。</p>
<p>​        <strong>选择操作</strong>。选择定义，给定一个关系R，同时给定一个选择的条件condition（简记con），选择运算结果也是一个关系，记作$\sigma_{con}(R)$，它从关系R中选择出满足给定条件condition的元组构成。数学描述$\sigma_{con}(R)={t|t\in R\and con(t)=‘真‘}$。其中条件con由逻辑运算符连接比较表达式组成，逻辑运算符有and，or，not，比较表达式$X\theta Y$，其中X，Y是t的分量，常量或简单函数，$\theta$是比较运算符，$\theta\in{&gt;,\ge,&lt;,\leq,=,\neq}$，优先级是${括号;\theta;\lnot;\and;\or}$。</p>
<p>​        <strong>投影操作及基本操作小结</strong>。投影定义，给定一个关系R，投影运算结果也是一个关系，记作$\prod_A(R)$，它从关系R中选出属性包含在A中的列构成。数学描述$\prod_{A_{i1},A_{i2},…,A_{ik}}(R)={&lt;t[A_{i1}],t[A_{i2}],…,t[A_{ik}]&gt;|t\in R}$。投影运算可以对原关系的列在投影后重新排列。投影操作是从给定关系选出某些列组成新的关系，选择操作是从给定关系中选出某些行组成新的关系。<strong>如果投影后有重复元组，则应去掉</strong>。</p>
<p><img src="/2020/02/28/data-base/image-20200308172053730.png" alt="，"></p>
<p>​        <strong>交操作</strong>。交定义，假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作$R\cap S$，它由同时出现在关系R和关系S中的元组构成。扩展操作是指可以通过基本操作组合来实现的。<strong>交可以通过差运算实现</strong>。</p>
<p>​        <strong>$\theta$连接操作及更名操作</strong>。<strong>$\theta$-连接定义</strong>，给定关系R和关系S，R与S的$\theta$连接运算结果也是一个关系，记作$R\bowtie_{A\theta B}S$，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B之间满足$\theta$条件的元组构成。数学描述$R\bowtie_{A\theta B}S=\sigma_{t[A]\theta s[B]}(R\times S)$。在实际应用中，$\theta$连接操作经常与投影，选择操作一起使用。<strong>更名操作</strong>（算作基本操作，一共六个），$\rho_AB$，将表名B更名为表名A。虽然在讲解$\theta$-连接操作时，使用笛卡尔积然后再进行选择来得到$\theta$连接结果，但是DBMS可直接进行连接操作，而不必形成笛卡尔积。<strong>等值连接操作定义</strong>，给定关系R和关系S，R与S的等值连接运算结果也是一个关系，记作$R\bowtie_{A=B}S$，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成，是一种特殊的$\theta$连接操作。</p>
<p>​        <strong>自然连接操作</strong>。自然连接操作定义，给定关系R和关系S，R与S的自然连接运算结果也是一个关系，记作$R\bowtie S$，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。数学描述$R\bowtie S=\sigma_{t[B]=s[B]}(R\times S)$。自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，要在结果中去掉重复的属性列。</p>
<p>​        <strong>关系代数操作之组合与应用训练</strong>。注意连接与积的差别。连接自己的时候要有更名操作。自然连接自己的结果是自己。注意并相容性的前提。</p>
<p><img src="/2020/02/28/data-base/image-20200308225739493.png" alt="image-20200308225739493"></p>
<p>​        <strong>除操作</strong>。除法运算经常用于求解“查询…全部的/所有的…”问题。除的前提条件，给定关系$R(A_1,A_2,…,A_n)$为n度关系，关系$S(B_1,B_2,…,B_m)$为m度关系，如果可以进行关系R与关系S的除运算，当且仅当，属性集${B_1,B_2,…,B_m}$是属性集${A_1,A_2,…,A_n}$的真子集即$m&lt;n$。除定义，关系R和关系S的除运算结果也是一个关系，记作$R\div S$，分两部分来定义，结果关系的属性集是R和S的属性集的差，结果关系中和S的笛卡尔积是R的子集。数学描述$R\div S={t|t\in\prod_{R-S}(R)\and\forall u\in S(tu\in R)}=\prod_{R-S}(R)-\prod_{R-S}((\prod_{R-S}(R)\times S)-R)$。</p>
<p>​        <strong>外连接操作</strong>。外连接定义，两个关系R与S进行连接时，如果关系R（或S）中的元组在S（或R）中管不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接。</p>
<p><img src="/2020/02/28/data-base/image-20200309165201055.png" alt="image-20200309165201055"></p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200309165411996.png" alt="image-20200309165411996"></p>
<h2 id="关系模型之关系演算"><a href="#关系模型之关系演算" class="headerlink" title="关系模型之关系演算"></a>关系模型之关系演算</h2><p>​        <strong>本讲学习什么</strong>。关系元组演算，关系域演算，安全性，关于三种关系运算的一些观点。关系元组演算公式的递归定义，关系域演算公式的递归定义。关系元组演算公式，与，或，非，存在量词，全程量词。用关系元组演算公式表达查询的思维训练。用QBE语言表达查询的思维训练。关系元组演算，域演算和关系代数在表达查询方面的思维差异。</p>
<p>​        <strong>什么是关系元组演算</strong>。关系演算以数理逻辑中的谓词演算为基础。SQL语言是继承了 关系代数和关系演算各自的优点所形成的。按照谓词变量的不同，可分为<strong>关系元组演算</strong>（以元组变量作为谓词变量的基本对象）和<strong>关系域演算</strong>（以域变量作为谓词变量的基本对象）。</p>
<p>​        关系元组演算公式的基本形式${t|P(t)}$，表示所有使谓词P为真的元组t的集合。$t[A]$表示元组t的分量，即t在属性A上的值。P是与谓词逻辑相似的公式，$P（t）$表示以元组t为变量的公式，可递归定义（原子公式属于，比较常量，比较分量，递归与，或，非，存在/全称量词）。运算符的优先级为${括弧;\theta;\exist;\forall;\lnot;\and;\or}$。公式只限于以上形式。</p>
<p>​        <strong>简单运用元组演算公式</strong>。通常使用t代表元组。结果使用集合表示。注意需要有$t\in R$，其中R是关系。</p>
<p>​        <strong>存在量词与全称量词</strong>。注意存在/全称量词中可以有对枚举变量的约束。</p>
<p>​        <strong>等价变换</strong>。$P(t)$公式，如同谓词演算一样，也有一系列演算的等价性。不等关系变换（需根据语境考虑多重情况）。德摩根定律。<strong>注意否定的定义</strong>。</p>
<p>​        <strong>四个典型示例</strong>。1.“全部学过”，2.“全部没学过”，3.“至少有一门学过”，4.“至少有一门没学过”。</p>
<p><img src="/2020/02/28/data-base/image-20200310225833107.png" alt="image-20200310225833107"></p>
<p>​        <strong>用元组演算实现关系代数操作</strong>。元组演算是一种用逻辑表达查询的思维，以元组为基本单位进行循环，先找到元组，再找到元组分量，进行谓词判断，元组演算与关系代数可以相互转换（有前提）。</p>
<p><img src="/2020/02/28/data-base/image-20200310230111288.png" alt="image-20200310230111288"></p>
<p>​        <strong>什么是域演算</strong>。关系域演算公式的基本形式${&lt;x_1,x_2,…,x_n&gt;|P(x_1,x_2,…,x_n)}$，其中$x_i$代表域变量或常量，P为以$x_i$为变量的公式。P可以递归地进行构造，与元组演算的相似，不同的是这里变量是$x_i$（代表一个域，列）。元组演算和域演算可以等价互换。域演算是一种非过程化语言，更适合用户来表达查询语言，尤其是各种数据库的最终用户的表达，如QBE。</p>
<p>​        <strong>什么是按示例查询——QBE</strong>。特点是操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可，是一种高度非过程化的查询语言，特别适合于终端用户的使用。QBE操作框架由四个部分构成1.关系名区，写欲待查询的关系名，2.属性名区，显示对应关系名区的所有属性名，3.操作命令区，写查询操作的命令，4.查询条件区，写查询条件。</p>
<p><img src="/2020/02/28/data-base/image-20200310232428565.png" alt="image-20200310232428565"></p>
<p>​        QBE的操作命令。1.Print/P. ，输出，2.Delete/D. ，删除，3.Insert/I. ，插入，4.Updata/U. ,更新。查询条件的形式为$\theta 参量$，如果省略$\theta$则默认为$=$。同一行之间是与关系。示例元素与投影，条件$\theta$参量中的参量也可以是域变量，用任何一个值（不必是结果中的值）带有下划线表示，被称为示例元素，示例元素下划线上面的值不起作用，被当作域变量名称来对待，只用于展位或是连接条件。或运算可以采用在多行书写，然后打印命令后使用不同的示例元素来表征，如果两行的示例元素相同则两行之间是与关系。也可以将$\and$，$\or$，$\lnot$条件写在操作命令区。也可以用示例元素实现多个表的连接。</p>
<p><img src="/2020/02/28/data-base/image-20200311000806289.png" alt="image-20200311000806289"></p>
<p>​        <strong>QBE应用训练</strong>。QBE可以实现关系代数的并，差，乘积，选择和投影运算。</p>
<p><img src="/2020/02/28/data-base/image-20200311170200826.png" alt="image-20200311170200826"></p>
<p>​        <strong>关系演算的安全性</strong>。关系演算安全性的定义，不产生无限关系和无穷验证的运算被成为是安全的。<strong>关系代数是一种集合运算，是安全的</strong>（集合本身是有限的，有限元素集合的有限次运算依旧是有限的）。<strong>关系演算不一定是安全的</strong>，例如${t|\lnot(R(t))}$可能表示无限关系，$(\exist u)(w(u))$ $(\forall u)(w(u))$可能导致无穷验证，前者是“假验证“，后者是”真验证“，检验所有元素就可能造成无穷。因此需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。<strong>安全约束有限集合DOM（$\psi$）</strong>，其中的每个符号要么是$\psi$中明显出现的符号，要么是出现在$\psi$中的某个关系R的某元组的分量。DOM主要用于约束$\psi$中一些谓词的计算范围，<strong>它不必是最小集合</strong>。安全元组演算表达式定义。安全域演算表达式定义类似。</p>
<p><img src="/2020/02/28/data-base/image-20200311172119819.png" alt="image-20200311172119819"></p>
<p>​        <strong>三种关系运算之比较</strong>。关系运算有三种，体现了三种不同的思维1.关系代数，以集合为对象，由集合到集合的变换，2.元组演算，以元组为对象，验证每个元组，3.域演算，以域变量为对象，取出域的每个变量进行验证。三种运算之间是等价的，<strong>关系代数与安全的元组演算表达式与安全的域演算表达式是等价的</strong>。三种关系运算都是非过程性的，域演算的非过程性大于元组演算大于关系代数。三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础，<strong>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</strong>，数据库语言可以基于这三种抽象运算来设计（例如ISBL语言基于关系代数的数据库语言，Ingres系统的QUEL语言）。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200311231814050.png" alt="image-20200311231814050"></p>
<h2 id="SQL语言之概述"><a href="#SQL语言之概述" class="headerlink" title="SQL语言之概述"></a>SQL语言之概述</h2><p>​        <strong>本讲学习什么</strong>。SQL语言概述，SQL语言之DDL-定义数据库，SQL语言之DML-操纵数据库。SQL-DDL的基本语句，CREATE DATABASE，CREATE TABLE，SQL-DML的基本语句，INSERT，DELETE，UPDATE，SELECT，SQL-SELECT语句的训练，正确表达各种需求。</p>
<p>​        <strong>SQL语言概述</strong>。SQL标准有SQL-86，SQL-89，SQL-92（或称为SQL2，标准关系数据库语言），SQL-99（或称为SQL3，面向对象数据库，对象关系数据库），SQL 2003，SQL 2006，SQL 2008（数据库应用程序），SQL X/Open标准（主要强调各厂商产品的可移植性）。SQL语言是集DDL，DML和DCL于一体的数据库语言，主要由9个单词引导的操作来构成1.DDL语句引导词，<strong>Create</strong>，<strong>Alter</strong>，<strong>Drop</strong>，模式的定义和删除，2.DML语句引导词，<strong>Insert</strong>，<strong>Delete</strong>，<strong>Update</strong>，<strong>Select</strong>，各种方式的更新与检索操作，各种复杂条件的检索，各种聚集操作，3.DCL语句引导词，Grant，Revoke，安全性控制：授权和撤销授权。交互式SQL（DBA），嵌入式SQL（应用程序员），动态SQL。</p>
<p>​        <strong>利用SQL建立数据库</strong>。假设学生选课数据库SCT。</p>
<p><img src="/2020/02/28/data-base/image-20200312224158748.png" alt="image-20200312224158748"></p>
<p>​        建立数据库，包括两件事，1.定义数据库和表（使用DDL），创建数据库 Create Database 数据库名，创建DB中的Table（定义关系模式） Create Table，DDL通常由DBA来使用，也有经DBA授权后由应用程序员使用。例如 create database SCT。create table。Primary key表示主键u二叔，每个表只能创建一个主键约束。Unique表示唯一性约束（即候选键），可以有多个唯一性约束。Not null表示非空约束，表示此列不允许有空值出现。SQL-92中定义了数据类型，char，varchar，int，numeric，real，date，time等。2.向表中追加元组（使用DML），DML通常由用户或应用程序员使用，访问经授权的数据库。insert into 表名（列名） values（值）。如果省略列名，则values后的值的排列，须与该表存储中的列名排列一致。</p>
<p><img src="/2020/02/28/data-base/image-20200321214739477.png" alt="image-20200321214739477"></p>
<p>​        <strong>利用SQL进行基本查询</strong>。Select 列名 From 表名 [Where 检索条件]，由三个子句构成。从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影，相当于投影。*表示投影所有列。检索条件的书写与选择运算的条件con书写一样，只是其逻辑运算符用and，or，not来表示。注意AND运算（即，又）的语句表达不是简单的AND。DISTINCT可以让检索结果中不出现重复的元组（Select DISTINCT）。结果排序问题，可以通过order by，在Where子句后面。模糊查询问题，可以使用like，%表示匹配零个或多个字符，_表示匹配任意单个字符，\转义字符。注意两个字符表示一个汉字。</p>
<p><img src="/2020/02/28/data-base/image-20200321221842223.png" alt="image-20200321221842223"></p>
<p>​        <strong>利用SQL进行多表联合查询</strong>。From 表名1，表名2表示笛卡尔积操作，如果是连接操作需要将条件写在Where子句中。用表名.属性名来限定该属性是属于哪一个表。如果要对同一个表进行连接操作则需要使用别名，使用as关键字，From中的as可以省略。</p>
<p><img src="/2020/02/28/data-base/image-20200321225245757.png" alt="image-20200321225245757"></p>
<p>​        <strong>结合SELECT的INSERT语句</strong>。元组新增Insert，新增一个或一些元组到数据库的Table中。元组更新Update，对某些元组中的某些属性值进行重新设定。元组删除Delete，删除某些元组。SQL-DML可以对记录集合集合进行更新操作。批数据新增命令形式，插入子查询结果中的若干条元组。当新增元组时，DBMS会检查用户定义的完整性约束条件等，如果不符合将不会执行新增动作。</p>
<p>​        <strong>结合SELECT的DELETE和UPDATE语句</strong>。Delete From Where。Update Set Where。注意子查询的使用。</p>
<p><img src="/2020/02/28/data-base/image-20200321231455352.png" alt="image-20200321231455352"></p>
<p>​        <strong>数据库定义的修正与撤销</strong>。修正数据库的定义，主要是修正表的定义。可以使用alter修正基本表的定义。Drop可以撤销基本表，Delete是删除表中的一些元组，Drop是删除表（删除表的数据和结构）。有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能，可以使用use和close。</p>
<p><img src="/2020/02/28/data-base/image-20200321232311560.png" alt="image-20200321232311560"></p>
<p>​        <strong>用SQL-Server进行练习</strong>。SQL Server是微软提供的一款关系数据库管理系统。Master是SQL Server中最重要的系统数据库，存储SQL Server中的元数据，Model是模板数据库，创建新数据库时会复制此数据库，Msdb代理服务数据库，提供一个存储空间，Tempdb临时数据库，为所有的临时表，临时存储过程及其他临时存储操作提供存储空间，断开连接时，临时表与存储过程自动被删除。有三种扩展名，<strong>主数据库文件.mdf</strong>，存储启动信息和部分或全部数据，数据库可以有多个数据库文件，只能有一个主数据库文件，<strong>辅助数据文件.ndf</strong>，放置.mdf定义数据库的其他数据，可有多个，<strong>日志文件.ldf</strong>，至少有一个事务日志文件。页面是SQL Server存储的最小单位，一页为8k。空间是8个连续的页面。</p>
<p>​        <strong>创建数据库</strong>主要是设计名称，存储空间和存放文件位置。可以通过查询分析器或者交互式数据库查询引擎。<strong>删除数据库</strong>，也可以利用查询分析器。<strong>备份数据库</strong>，SQL的备份是动态的。有完全数据库备份，差异备份，事务日志备份，数据库文件和文件组备份。<strong>恢复数据库</strong>，数据库的恢复是静态的。<strong>数据库授权</strong>，语法形式grant 权限 on 表名 to 用户名，权限有select，update，insert，delete，exec，dri（声明引用完整性，用户可能需要通过其他的表来检验其输入的数据但是不能直接读取这个表，这种情况下，用户就需要DRI权限而不是Select权限）。<strong>创建表</strong>，不同用户可以创建相同表名的表，同一个用户不行，使用时需要加上所有者。T-SQL是SQL Server的标准。<strong>增加，修改表的字段</strong>，ALTER TABLE ADD | ALTER 字段名&lt;类型&gt;。<strong>创建，删除与修改约束</strong>，CONSTRAINT 约束名 约束类型（列名）。<strong>在表中插入数据</strong>，INSERT INTO。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200322214506033.png" alt="image-20200322214506033"></p>
<h2 id="SQL语言之复杂查询与视图"><a href="#SQL语言之复杂查询与视图" class="headerlink" title="SQL语言之复杂查询与视图"></a>SQL语言之复杂查询与视图</h2><p>​        <strong>本讲学习什么</strong>。子查询运用，结果计算与聚集函数，分组查询与分组过滤，利用SQL语言实现关系代数操作，视图及其运用。SQL-SELECT IN | NOT IN，$\theta$ some，$\theta$ all，Exists | NOT Exists。SQL-SELECT，聚集函数，GROUP BY，HAVING。视图及其应用。</p>
<p>​        <strong>IN子查询</strong>。集合成员资格。为什么需要子查询，集合成员资格，集合之间的比较，集合基数的测试。子查询是出现在Where子句中的Select语句被称为子查询，子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。有三种子查询1.（NOT） IN-子查询，2.$\theta$-Some/$\theta$-All子查询，3.（NOT） EXISTS子查询。</p>
<p>​        （NOT） IN子查询。语义是判断某一表达式的值是否在子查询的结果中。带有子查询的Select语句区分为内层和外层。<strong>非相关子查询</strong>，内层查询独立进行，没有设计任何外层查询相关信息的子查询。<strong>相关子查询</strong>，内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询，只能外层向内层传递参数。</p>
<p><img src="/2020/02/28/data-base/image-20200322225803094.png" alt="image-20200322225803094"></p>
<p>​        <strong>$\theta$-Some子查询</strong>。集合之间的比较。语法中，$\theta$是比较运算符。语义是将表达式的值与子查询的结果进行比较，Some是指子查询结果真有一个为真则为真，All是指子查询结果所有为真才为真。</p>
<p>​        <strong>Exists子查询</strong>。集合基数的测试。语义是子查询结果中有无元组存在。可以用not Exists实现反义（所有，取两次反等）。</p>
<p><img src="/2020/02/28/data-base/image-20200322234255074.png" alt="image-20200322234255074"></p>
<p>​        <strong>结果计算与聚集计算</strong>。Select子句后面可以写计算表达式或者聚集函数。聚集函数，SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc，分别是COUNT，SUM，AVG，MIN，MAX。</p>
<p><img src="/2020/02/28/data-base/image-20200322234857477.png" alt="image-20200322234857477"></p>
<p>​        <strong>分组聚集计算与分组过滤</strong>。<strong>分组</strong>，SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。聚集函数是不允许用于Where子句中的，Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤。<strong>分组过滤</strong>，若要对集合（即分组）进行条件过滤，即满足条件的集合/分组留下，不满足条件的集合/分组删除，使用Having子句。Having子句，又称发呢组过滤子句，需要有Group by子句支持（即要有Group by子句）。<strong>Where子句是对每个元组进行检查，Having子句是对分组进行检查</strong>。注意Where子句会限制Group中的元组。</p>
<p><img src="/2020/02/28/data-base/image-20200323171553186.png" alt="image-20200323171553186"></p>
<p>​        <strong>用SQL表达并交差操作</strong>。交运算符和差运算符并没有增强SQL的表达能力。有些DBMS不一定支持。</p>
<p><img src="/2020/02/28/data-base/image-20200323171750055.png" alt="image-20200323171750055"></p>
<p>​        <strong>用SQL处理空值</strong>。空值会影响聚集函数，算数，比较或逻辑运算等。以前DBMS将空值按默认值处理会产生不正确性。注意不能写成= null，空值是不参与运算的。现在DBMS中，除了is [not] null之外，空值不满足任何查找条件，参与的算数运算的值为null，参与的比较运算结果为false，参与聚集运算，除了count(*)之外的其他聚集函数都忽略null（平均值时会变更N）。</p>
<p><img src="/2020/02/28/data-base/image-20200323172325802.png" alt="image-20200323172325802"></p>
<p>​        <strong>用SQL表达连接与外连接操作</strong>。通过From后面的表名进行连接。inner join即$\theta$-连接。using是用公共属性子集做判断。</p>
<p><img src="/2020/02/28/data-base/image-20200323173136007.png" alt="image-20200323173136007"></p>
<p>​        <strong>SQL-SELECT小结</strong>。</p>
<p><img src="/2020/02/28/data-base/image-20200323173206890.png" alt="image-20200323173206890"></p>
<p>​        SQL-SELECT的完整语法。出现SQL3后逐渐由SQL转变为OQL。基本的SQL中另一SELECT-FROM-WHERE只能出现在WHERE子句。新标准中引入对象概念，可以在能使用聚集的任何位置使用SELECT-FROM-WHERE（即FROM，SELECT，WHERE中）。</p>
<p><img src="/2020/02/28/data-base/image-20200323210917003.png" alt="image-20200323210917003"></p>
<p>​        <strong>SQL视图</strong>。对应概念模式的数据在SQL中被称为基本表，对应外模式的数据被成为视图。视图包括外模式和E-C映像。基本表是实际存储于存储文件中的表，基本表中的数据是需要存储的，视图在SQL中只存储其由基本表导出视图所需要的公式（映像信息），不存储数据，动态产生与维护。</p>
<p>​        视图需要先定义再使用。with check option是修改时要检查被修改元组是否满足视图定义中子查询中定义的条件表达式。使用视图可以像使用表一样，方便操作。有时候视图无法更新1.视图定义select使用了聚集函数，2.select使用了unique或distinct，3.包括了group by，4.包括算术表达式计算出来的列，4.没有主键。可以使用Drop撤销视图。</p>
<p><img src="/2020/02/28/data-base/image-20200323214526120.png" alt="image-20200323214526120"></p>
<p>​        本讲总结。</p>
<p><img src="/2020/02/28/data-base/image-20200323214621411.png" alt="image-20200323214621411"></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://1170300229.github.io/2020/02/28/data-base/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://1170300229.github.io/2020/02/28/data-base/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
