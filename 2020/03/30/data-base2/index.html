<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.png">
	<link rel="shortcut icon" href="/img/logo.png">
	
			    <title>
    Orange's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="orange">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">ORANGE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">创作</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/其他/">其他</a></li><li><a class="category-link" href="/categories/课堂笔记/">课堂笔记</a></li><li><a class="category-link" href="/categories/野生技能/">野生技能</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简介">
		                简介
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="朋友">
		                朋友
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/1170300229" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(/thumbnailImg/data-base2.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>数据库课堂笔记Ⅱ</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="数据库课堂笔记Ⅱ"><a href="#数据库课堂笔记Ⅱ" class="headerlink" title="数据库课堂笔记Ⅱ"></a>数据库课堂笔记Ⅱ</h1><h2 id="SQL语言与数据库完整性和安全性"><a href="#SQL语言与数据库完整性和安全性" class="headerlink" title="SQL语言与数据库完整性和安全性"></a>SQL语言与数据库完整性和安全性</h2><p>​        主要学习，完整性概念，规则，静态动态约束，安全性的概念，访问规则，权力与授权。</p>
<p>​        完整性的概念（正确的，有效的，一致的），有广义/狭义完整性。主要讨论语义完整性（狭义完整性）。完整性涉及到实体完整性，参照完整性，用户自定义完整性。数据库设计中也有完整性约束条件。引发完整性问题的是误操作，要方式和避免数据库中不合理数据的出现，DBMS防止语义不合理现象。DBMS通过完整性控制程序保证完整性（流程图）。</p>
<p>​        完整性约束规则是（O，P，A，R），O是数据集合，P是谓词，A是触发条件，R是响应动作。</p>
<p>​        完整性规则的分类。按约束对象分类，1.域完整性约束条件，对一列有影响，2.关系完整性约束条件，涉及到多列，或称表完整性。从约束来源分类，1.结构约束，来自模型的约束，函数依赖等，关心是否相等，是否允许空值，2.内容约束，来自用户的约束，主要是取值范围等。按约束状态分类，1.静态约束，任何时候都要满足，2.动态约束，是否能够发生改变。</p>
<p>​        静态约束，可以实现域完整性（列完整性）和关系完整性约束（表完整性）。根据约束规则，O是表或者列，A和R可以不用表达（默认）。Create Table有三种功能，定义关系模式，完整性约束和物理存储特性，可以同时定义列完整性和表完整性。<strong>Create Table列约束语法</strong>。给约束命名是为了方便撤销。search_cond是谓词。colname可以省略，意为外键和目标列名相同。CASEADE是删除此行。NOT NULL加UNIQUE就是主键/候选键。<strong>Create Table表约束语法</strong>。check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。可以用ALTER TABLE进行撤销或者追加。ADD DROP MODIFY，有些DBMS支持独立的追加约束，注意书写格式可能有些差异。</p>
<p>​        断言，可以实现完整性约束。断言是一个谓词表达式，表达了希望数据库总能满足的条件。表/列约束就是一些特殊的断言。断言多了会增加数据库负担。现在断言使用比较少。语法形式，Create Assertion assertion_name check()。注意exists。</p>
<p>​        动态约束，可以实现触发器。Trigger实际上是一段程序，可以在特定的时刻被执行。Create Trigger的语法。REFERENCING是变量声明。STATEMENT是对每一条SQL语句。BEFORE和AFTER分界线是是否修改了数据。</p>
<p>​        完整性总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200330235629352.png" alt="image-20200330235629352"></p>
<p>​        安全性的概念，免受非法，非授权用户的使用，泄露，更改或破坏。数据库安全性刊涉及许多方面。DBMS的安全机制，1.自主安全性机制：存取控制，在用户之间传播，2.强制安全性机制，数据和用户强制分类，3.推断安全性机制，4.数据加密机制。DBA需要划分好数据的安全级别以及用户的安全级别。</p>
<p>​        自主安全性机制。通过授权机制来实现。用户使用SQL-DCL来定义安全性控制规则。安全性控制程序（流程图）。</p>
<p>​        访问规则AccessRule（S，O，t，P），S是请求主体（用户），O是访问对象，t是访问权利，P是谓词。访问对象可大可小，属性/字段，记录/元组，关系，数据库，权利包括创建，增，删，改，查等，谓词是拥有权利需要满足的条件。S访问O是在P的条件下有t权利。有两种控制方法，按名控制安全性：存储矩阵（S，O，t，P），按内容控制，涉及到P。</p>
<p>​        两种自主安全性机制。1.存储矩阵，表示为主体-数据对象矩阵。大部分DBMS都是这种结构。算法是根据用户输入的Select-From-Where语句中使用的表或数据项进行检查，可以实现S，O，t，2.视图，定义用户可以访问的视图，限制用户对关系中某些数据项的存取，P可以放在视图中实现，视图也是一个新的对象O，可以实现S，O，t，P。</p>
<p>​        SQL语言实现自主安全性。数据库安全性属于DCL。用户级别：超级用户（DBA），账户级别（程序员用户），关系级别（普通用户）。权利级别有1.Select，读，2.Modify，更新，Insert，Update，Delete，3.Create，创建，Create，Alter，Drop，级别高的拥有级别低的权利。<strong>SQL授权命令GRANT</strong>。WITH GRANT OPTION是否允许传播被授权的权利。ON后面可以接表后者视图。public是公开的。REVOKE是收回授权。</p>
<p>​        授权过程，1.DBA创建DB，创建账户，2.分配用户账户级别的权利，3.用户创建基本表或视图，并拥有该表/视图的所有权利，4.传播权利。传播范围包括两个方面，水平传播数量和垂直传播数量，前者是一层传播了多少个用户，后者是多少层。有些系统可能控制传播范围。有重复授权问题。</p>
<p>​        强制安全性，对数据对象和用户进行安全性分级（绝密，机密，可信，无分类）。访问规则是高级别用户可以访问低级别数据对象，反之不能，高级别用户不能改低级别数据，除非提升数据级别。强制安全性的实现，定义关系模式时需要引入安全性分级特性或称分类特性。<strong>分类特性定义语法</strong>。强制安全性机制是的关系形成为多级关系，需要特殊的处理技巧。</p>
<p>​        安全性总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200330235504023.png" alt="image-20200330235504023"></p>
<h2 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h2><p>​        主要讲了嵌入式SQL语言的概述，变量声明和数据库连接，数据集与游标，可滚动游标与数据库的增删改，状态捕获及错误处理机制。</p>
<p>​        嵌入式SQL语言概述。优点，记录集合操作，非过程性操作，一条语句可以实现复杂的查询效果。缺点是对普通用户复杂，一条SQL不能完成所有操作，在SQL语言检索结果上进行处理。高级语言+SQL语言是解决方案，其中高级语言称为宿主语言。嵌入式SQL和交互式SQL语言不太一样，1.有引导词exec sql，可以预编译，2.增加了into，3.：的引进。高级语言（语句）和嵌入式SQL语句和DBMS和DB的关系图，八个问题，1.连接问题，2.宿主程序的变量传递，3.SQL语句的执行，4.SQL检索结果船体，5.静态SQL的常量替换为变量，6.是否发生错误，7.动态SQL，已知表名和字段，8.动态SQL，未知表名和字段。</p>
<p>​        变量声明和数据库连接。有：的是高级语言程序变量，可以使用begin declare section;end declare section;的语法声明。注意数据库中宿主语言字符串可能长度多一，因为结束符\0，有些宿主程序变量类型自动转换只有部分DBMS支持。连接语法，exec sql connect to as user或exec sql connect to default，注意不同DBMS可能语法不一致。断开数据库连接语法，exec sql disconnect或exec sql disconnect current，注意不同DBMS可能语法不一致。SQL执行的提交和撤销语法。</p>
<p>​        提交和撤销。事务，是一个存取或改变数据库内容的程序的一次执行，一条或多条SQL语句的一次执行被看作一个事务。事务一般由应用程序员提出，结束时需要提交（生效）或者撤销（无效，恢复至原状态）。事务从微观角度是一种控制数据库的手段（具体定义），以便数据库能够提供<strong>一致性</strong>状态转换的保证（要么全部执行，要么全不执行）。事务的特性，ACID，原子性，一致性，隔离性（处理并发），持久性。事务的第三个定义，具有ACID特性的若干数据库基本操作的组合体被称为事务，事务处理是DBMS的核心技术。</p>
<p>​        嵌入式SQL语言的例子。sqlca是通讯区，先声明使用sqlca，然后声明一些变量，然后设置动态错误捕获的语句，连接数据库，再实现查询并提交，再断开数据库连接并结束，可能会跳到notfound和report_error（需要声明），再Rollback并断开连接。</p>
<p>​        数据集和游标，解决了问题3，4，5。检索的单行结果，可将结果直接传到宿主程序的变量中。into后面加上宿主程序的变量。如果是多行结果，则需要用游标，是指向结果集合的指针，使用fetch into可以读取结果。游标使用要先定义，再执行，然后一条一条处理，最后关闭，注意游标的语法。游标在open（执行）的时候才真正执行，可以多次打开，多次记录。</p>
<p>​        游标应用示例。如果出错了需要Rollback。定义中可能定义只读的（For read only），或者更新。打开和关闭的语法。</p>
<p>​        可滚动的游标和数据库的增删改。标准的游标只能从上往下读取。ODBC提供了可滚动的游标，许多DBMS不能支持可滚动游标，但是可以通过ODBC实现。在声明游标的时候可以声明是否为可滚动游标，FETCH后面可以选择如何移动。可滚动游标上下界分别是BOF和EOF。</p>
<p>​        数据库记录的删除有查找删除和定位删除。查找删除可以通过Select-From-Where查找删除，定位删除是通过游标删除。更新也有查找更新和定位更新。插入只有一种类型。注意执行一次fetch只能取一次值。</p>
<p>​        状态捕获及错误处理机制。解决问题6。状态是指嵌入式SQL语句的执行状态，如出错状态。状态捕获由三部分组成1.设置SQL通信区，2.设置状态捕获语句，3.状态处理语句。SQLCA是一个被声明过的内存信息区，其中成员变量用来记录SQL语句执行的状态，是DBMS与宿主程序之间交流的桥梁。</p>
<p>​        状态捕获语句的语法。whenever是一个“条件陷阱”，<strong>生效范围是之后的所有SQL调用，直到出现相同条件的whenever为止（注意GOTO）</strong>。状态捕获中的状态有SQLERROR（是否有SQL语句出错），NOT FOUND（没有找到相应记录），SQLWARNING（警告），都对应着whenever后面的condition。action中有CONTINUE，GOTO，STOP，DO，CALL（DO和CALL都是调用函数）。状态捕获语句容易引发无限循环，为了避免无限循环注意添加CONTINUE。DBMS系统记录状态信息的三种方法，1.sqlcode，等于0是成功，小于0是出错，大于0是警告，2.sqlca.sqlcode，3.sqlstate，如果不需要知道错误类型只需要知道状态（隐式状态处理），如果需要则要知道sqlcode（显式状态处理），注意显式状态处理的位置和错误捕获的作用域。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200401220109052.png" alt="image-20200401220109052"></p>
<h2 id="嵌入式SQL语言之动态SQL"><a href="#嵌入式SQL语言之动态SQL" class="headerlink" title="嵌入式SQL语言之动态SQL"></a>嵌入式SQL语言之动态SQL</h2><p>​        主要讲了动态SQL的概念和作用，SQL语句动态构造，动态SQL执行方式，数据字典与SQLDA，ODBC和JDBC的简介。</p>
<p>​        动态SQL的概念。动态SQL解决了问题3和7。静态SQL是SQL语句已经写好了的，只需要传入高级语言中的一些参数。动态SQL中SQL语句是一个字符串来被执行，通过execute immediate语法。如何设计用户的操作界面，可以遵循QBE的思路（转换图），变成一种界面操作表单型语言。</p>
<p>​        SQL语句的动态构造。用户在界面输入筛选条件。动态构造字符串作为SQL语句。dtoa函数是用来转换为字符串类型。构造动态SQL语句的时候要写好基本部分，SQL中的字符串需要加引号，添加逻辑运算符，数值变量转换为字符串。trim是去掉两边的空格，len是求长度。</p>
<p>​        动态SQL有两种执行方式，1.立即执行，运行时编译并执行，是完整的语句，2.Prepare-Execute-Using语句，PREPARE语句先编译，EXECUTE语句执行时用USING传入动态参数，实现延迟执行，通常作为SQL语句的字符串中有对高级语言的变量的引用。一种构造的字符串SQL内部没有“变量”参数，一种构造的字符串SQL内部有“变量”参数。</p>
<p>​        数据字典与SQLDA。解决问题8。数据字典，又称为系统目录，目录表，系统视图，本身是一些表和视图的集合，存储了系统数据的集合，是元数据，即关于数据的数据。不同的DBMS存储方式不一样，但会有一些信息对DBA公开，DBA可以使用一些特殊SQL命令来检索。</p>
<p>​        数据字典的内容构成，通常存储的是数据库和表的元数据，即模式本身的信息，1.与关系相关的信息，如关系的名字，属性名及其类型，视图的名字及其定义，完整性约束，2.用户与账户信息，密码，3.统计与描述性数据，4.物理文件组织信息，5，索引相关信息。</p>
<p>​        数据字典的结构。可能的字典数据结构，有关系/属性/用户/索引/视图元数据（表）。X/Open标准中的目录表Info_Schem.Tables，该表中的每一行是一个已经定义的表的有关信息。表的模式名是指模式名+表名，这里模式是指每个用户有一个模式，数据库拥有者为默认的模式名，可以使用Create Schema语句来创建模式，可以让不同的用户有相同的表名。Oracle数据字典由视图组成，有三种不同的形式，三种前缀是UESER_，ALL_，DBA_，由三个前缀+TABLE组成，是有关表的信息，由三个前缀+Columns组成，是有关列的信息。Oracle还定义了其他视图，也可以使用SQL*PLUS进行交互式访问。</p>
<p>​        更为复杂的动态SQL。用户要确定读哪个表的时候需要从数据字典中选出表。SQLDA称为SQL描述区，存储的是数据库表的定义信息，是一种内存的数据结构，内可装载关系模式的定义信息，不同DBMS提供的SQLDA格式并不是一致的，SQLCA存储的是SQL语句和DBMS交互的状态信息。</p>
<p>​        什么是ODBC。是不同语言的应用程序与不同数据库服务器之间通讯的标准，包括一组API，通过调用ODBC API，可以是实现与数据服务器的连接，向数据库服务器发送SQL命令，处理返回的结果。具体的DBMS提供一套驱动程序，Driver库函数供ODBC调用，以便实现数据库与应用程序连接，ODBC可以配合很多高级语言使用。ODBC对应用程序提供统一的接口。</p>
<p>​        应用程序如何通过ODBC连接数据库服务器。当应用程序调用ODBC API时，ODBC API会调用具体的DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯。ODBC应用程序首先要分配一个SQL环境再产生一个数据库连接的句柄。连接举例。应用程序使用SQL ExecDirect向数据库发送SQL命令，使用SQLFetch获取产生的结果元组，使用SQLBindCol绑定C语言变量与结果中的属性。ODBC也可以对动态SQL预编译，动态参数传递，获取元数据等，有些可以自动提交，但是有些需要显式地提交和撤销。</p>
<p>​        什么是JDBC。JDBC是Java版的JDBC。包括两个部分1.核心API，2.扩展API，包括连接池，分布式事务等。JDBC的核心类1.DriverManager，处理驱动的调入并且对产生新数据库连接提供支持，2.Driver，通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动，3.Connection，代表对特定数据库的连接。Satement是对特定数据库执行SQL，PreparedStatement用于预编译，CallableStatement是对内嵌过程的调用，ResultSet是返回的结果。</p>
<p>​        JDBC使用的基本过程，1.打开连接，2.创建“Statement”对象，设置查询语句，3.使用Statement执行查询，4.得到结果，5.处理错误的额外机制（具体语法）。Update，Execute query and fetch and print results。</p>
<p>​        嵌入式语言，ODBC和JDBC的比较。嵌入式语言，建立数据库连接-声明一个游标-打开游标-获取一条记录-关闭游标-断开数据库连接，以语句为中心。ODBC是以API函数来执行的，建立数据库连接-分配语句句柄-用句柄执行SQL-建立高级语言变量与句柄属性的对应-获取一条一条记录-释放语句句柄-断开数据库连接，以函数操作SQL。JDBC，建立数据库连接-创建语句对象-用语句对象执行SQL，并返回结果对象-从结果对象获取一条一条记录-提取对象的属性值传给高级语言变量-释放语句对象-断开数据库连接，以对象为中心。基于ODBC/JDBC的数据库访问，和普通的数据库访问的差别，对多个数据库系统进行进一步抽象。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200403171351470.png" alt="image-20200403171351470"></p>
<h2 id="数据建模：思想与方法"><a href="#数据建模：思想与方法" class="headerlink" title="数据建模：思想与方法"></a>数据建模：思想与方法</h2><p>​        主要讲了理解数据建模与数据库设计。理解并掌握E-R模型/IDEF1X模型，能够用E-R/IDEF1X模型准确理解现实世界并进行数据库设计，理解并掌握数据库设计理论，能够运用数据库设计理论分析数据库设计的正确性。</p>
<p>​        这一讲主要讲了基本思想，ER模型，Chen方法，Crow‘s foot方法，案例，设计中的抽象。</p>
<p>​        为什么要数据建模与数据库设计。成功的软件开发有需求的理解与表达。数据需求的理解与表达是非常重要的。</p>
<p>​        数据模型和概念模型。表达计算机世界的模型称数据模型，表达信息世界的模型称概念数据模型，信息世界是对现实世界的理解与抽象（<strong>流程图</strong>）。抽象是分层次的，现实世界到观念世界/信息世界到数据世界/计算机世界，数据世界/计算机世界包括逻辑层和物理层。从待表达的问题到概念模型到数据模型。<strong>数据建模</strong>指的是从待表达的问题到概念模型，<strong>数据库设计</strong>指的是从概念模型到数据模型。</p>
<p>​        什么是抽象。抽象是理解-区分-命名-表达。现实世界需要理解，理解的标志是区分，区分的标志是命名，抽象的最终结果是正确的表达。</p>
<p>​        E-R模型。E-R模型的基本观点，世界是由一组称作实体的基本对象和这些对象之间的联系构成的。建模思想是理解-区分-命名，需要区分及命名哪些要素，表达方法是用不同的图形表达被区分的不同要素。E-R模型给出了基本概念，实体，属性，联系，关键字/码。抽象的概念赋予具体的语义就是建模。</p>
<p>​        实体。实体是客观存在并可相互区分的事物，实体有类（实体，实体的型）和个体（实体的实例，实体的值）的概念。一类实体具有相同或相似的特性。</p>
<p>​        属性。实体所具有的某一方面的特性。实体用属性来刻画。实体由实体的型来刻画，实例由实体的值来刻画。属性有<strong>单一属性和复合属性</strong>。复合属性比如说家庭住址包括了省份和详细住址，在关系模型中，复合属性一定要转化为单一属性（关系的第一范式）。属性也有<strong>单值属性和多值属性</strong>。属性还有<strong>可空值属性和非空值属性</strong>。属性还有<strong>导出属性</strong>。实体还有特殊的属性，这个特殊的属性称为关键字/码，实体中能够用其值唯一区分开每一实例的属性或属性组合。</p>
<p>​        联系，指一个实体的实例和其他实体实例之间所可能发生的联系。联系的元/度，指参与联系的实体的数目。联系也是需要处理和存储的。实体是相对稳定的，联系可以是多样化的。一元联系，同一个实体中的实例之间发生的联系，为了区分引入角色。角色是实体在联系中的作用称为实体的角色，当同一实体的不同实例参与联系时，为区别各实例参与联系的方式，需要显式指明其角色。</p>
<p>​        联系与联系的基数。对于联系还有一对一的联系，一对多的联系和多对多的联系。判断是其中一个实体可以对多少个另一实体的。联系的基数，实体实例之间的联系的数量。常见的映射基数如上，有一对一，一对多，多对多几种情况。进一步，联系的基数还要区分0个，1个，不定数目的多个还是固定数目的多个。最小基数到最大基数之间用并排的两个点连接，一对一，一对多，多对多是用冒号。完全参与联系，该端实例至少有一个参与到联系中，最下基数为1，部分参与联系是0。区分是为了空值的处理，是否允许有空值。</p>
<p>​        Chen方法，E-R模型模型的图示化表示方法，还有Crow’s Foot方法，IDEF1X方法（工程化方法）。Chen方法用矩形框表达实体，用椭圆表示属性，双线椭圆表示多值属性，虚线表示导出属性，下划线表示关键字/码，直线表示连接实体和属性，菱形框表示联系，直线表示连接实体与联系，直线表示连接联系和属性，标有相同数字是复合关键字，标有不同数字是多组关键字。不同的联系的表达方法，1有箭头，多无箭头，完全参与是双直线，部分参与是单直线，也可以在直线上标注0，1，n和m，最少基数和最大基数。联系也需要命名和表达。联系也可以有属性，每个实体至少要给出关键字，联系与实体间连线不是随意画的，其代表实体的关键字要作为联系的属性。直线上标记有文字是联系的角色。</p>
<p>​        用Chen方法建模案例。1.理解需求，寻找实体，实体是能够用重叠量词形容的，2.用属性刻画每一个实体，3.确定每一个实体的关键字/码，4.数据建模的重点是分析实体之间的联系，标注联系属性，基数，5.检查是否覆盖了需求，E-R图是对需求的理解与表达，要覆盖需求，E-R图的绘制要符合规范，Chen方法。</p>
<p>​        Crow‘s foot方法。实体是矩形框，实体的名称卸载横线上面。属性，在实体框横向下面，关键字是在属性下加下划线。比Chen方法好的地方在于省空间。联系，菱形框表示，也可以将菱形框省略而直接以联系名来替代。联系的基数，使用不同的联系连接地方的图形表示。图形表达业务规则。一元联系的表达，角色可以写在联系的横线上，使用虚线连接。</p>
<p>​        Crow’s foot方法示例，E-R图是对需求的理解与表达，要覆盖需求，E-R图的绘制要符合规范，Crow’s foot方法。</p>
<p>​        数据库设计的抽象。什么是信息，信息是现实世界中事物在人们头脑中的一种反映。数据库设计往往因为忽视了信息（之间联系）的细致分析而造成设计失误，数据库设计能力的高低往往体现在信息（及其联系）的正确分析上，体现在理解现实世界能力的高低。三个世界与多层抽象，现实世界到信息世界到计算机世界。型与值，是基本的抽象。进一步还有型与“型的型”，“型的型”例如属性。现实层到抽象层到逻辑层到物理层。越抽象，语义信息越少，概括性越高，越反映共性信息，表征的范围也越大。检验抽象正确性的方法，能够依据现实抽象出来（抽象化），同时也能依据抽象的信息和抽象规则还原为被抽象对象（具体化）。</p>
<p>​        数据模型，不同范围的人对现实世界中事物的描述和抽象可能是不同的，为了避免认识上的不一致，需要统一的概念与统一的表达方法，统一是为了信息交流，信息共享。数据模型是一组相互关联且已严格定义的概念集合，是用于刻画或描述现实世界，信息世界或计算机世界的模型。表达计算机世界的模型称数据模型，表达信息世界的模型称概念数据模型，简称概念模型。数据库的抽象，将现实世界转化为概念方法，转化为表/视图。分层级抽象，待表达的问题到概念级抽象到实现级抽象。另一种抽象，方法论，用一般性方法指导抽象，抽象过程，抽象结果的表达方法。</p>
<p><img src="/2020/03/30/data-base2/image-20200408221151538.png" alt="image-20200408221151538"></p>
<p>​        建模的不同层次，有模型与元模型，模型（型）与实例（值），注意层次图。</p>
<p><img src="/2020/03/30/data-base2/image-20200408222439561.png" alt="image-20200408222439561"></p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200408222704652.png" alt="image-20200408222704652"></p>
<h2 id="数据建模：工程化及案例分析"><a href="#数据建模：工程化及案例分析" class="headerlink" title="数据建模：工程化及案例分析"></a>数据建模：工程化及案例分析</h2><p>​        主要讲了IDEF1X图。</p>
<p>​        什么是IDEF1X。IDEF1X是IDEF标准之一，IDEF0是功能模型的描述方法，IDEF1是信息模型的描述方法，IDEF2是动态模型的描述方法。后来IDEF被扩展成IDEF1X。后来IDEF的发展还有IDEF3，IDEF4，IDEF5。IDEF1X是E-R模型扩充语义而形成的，或者说IDEF1X是E-R图的细化。IDEF1X是一种进行数据建模或数据库设计的工程化方法。IDEF1X中的重要概念，实体被细分为独立实体（强实体），从属实体（弱实体），联系被细分为可标定连接联系，非标定连接联系，分类联系，非确定联系，属性被细分为属性，主关键字/主码（主属性），次关键字/候选码，外来关键字/外来码（外来属性）。IDEF1X是一种图示化，工程化的建模方法，也可以被认为是E-R模型的第三种表示方法。</p>
<p>​        IDEF1X两种实体的区分。实体，一个“实体”表示一个现实和抽象事物的集合，这些事物必须具有相同的属性和特征，这个集合的一个元素就是该实体的一个实例。实体被区分为独立实体和从属实体，在扩展E-R图中，独立实体又称强实体，从属实体又称弱实体。独立实体是指一个实体的实例都被唯一标识而不决定于它与其他实体的联系，比如合同，在IDEF1X图中用矩形框来表示。从属实体，例如合同中的合同条目，是依赖于合同的，从属实体需要从其他实体继承属性作为关键字的一部分，主关键字包含了外来属性的实体为从属实体，从属实体用圆角方框来表示。从属实体的关键字中有外码。从属实体的实体依赖于独立实体实例的存在而存在。属性是表示一类现实或抽象事物的一种特征或性质，关键字是能唯一确定实体每一个实例的属性或属性组。关键字被区分为主关键字和次关键字（AK表示次关键字，如果AK数字相同，说明是共同组成次关键字）。外来关键字用FK标识，如果FK出现在主关键字，那么这个实体就是一个从属实体。一元联系需要重新命名的时候可以采取作用名.继承属性名，作用名是在这个实体当中的属性名，继承属性名是继承的其他实体的属性。存在一个联系只能有一个外来关键字，<strong>被继承属性只能是主关键字所包含的属性</strong>。</p>
<p>​        IDEF1X的标定联系和非标定联系。联系有连接联系，分类联系和不确定联系。连接联系又被分为标定联系和非标定联系。标定联系是指子实体的实例都是由是父实体的联系而确定的，父实体的主关键字是子实体主关键字的一部分，例如零件和零件工序，实线加圈。非标定联系，子实体的实例能够被唯一标识而无需依赖与其实体的联系，父实体的主关键字不是子实体的主关键字，虚线加圈。连线的圆圈指向一对多的多端。父实体的一个实例可与子实体的0个，1个或多个实例相联系，在子实体端标注P（1或大于1）/Z（0或1）/n（确定数目）/&lt;省略&gt;（0，1或大于1）。</p>
<p>​        IDEF1X的非确定联系。标定联系和非标定联系可以是一对一或者一对多的联系，非确定联系是实体之间的多对多的联系。非确定联系通过引入相交实体（相关实体）来分解为若干个一对多的联系来表达。相交实体本身就是一种联系。</p>
<p>​        IDEF1X的分类联系。分类联系是指一个一般实体实例及多个分类实体实例相互之间的关系，把一个一般实体的实例分类为多个分类实体的实例当中。分类实体与一般实体具有相同的主关键字。不同的分类实体有不同的分类属性。例如零件可以分为自制件和外购件。分类联系有个鉴别器属性，是一般实体里的某一个属性，用这个属性可以把实例分类。具体化，分组/分类的过程。泛化，高层实体与若干个低层实体之间的包含关系。ER图中的分类联系通过倒三角加上ISA来表示。由于分类实体的主关键字和一般实体的相同，因此可以省略主关键字。<strong>高层实体的属性都被继承</strong>。完全分类联系和非完全分类联系，每个一般实体的实例都是分类实体中的某一个的实例就是完全分类联系，否则是非完全分类联系，完全分类联系是两个横线，非完全分类联系是一个横线。分类联系不等于分类。</p>
<p>​        IDEF1X的案例讲解。注意作用名.继承属性名。根据客户跟踪表构造ER图，分析表中主要项目，建立联系。对于文字需求，可以提取名词来作为初步的实体，然后可以考虑所有实体之间可能产生的联系，有时需要对表的分解，化复杂为简单。将表格中的多值属性作为一个新表。如果需要对一个表建模，可以从列名开始分析实体。IDEF1X模型的读图训练，通过IDEF1X图理解需求，读图的基本方法，检查每个实体能否用重叠量词形容，是实体还是实体的属性，检查实体的关键字能否唯一确定每个实例，检查实体之间联系绘制及命名的正确性，检查属性继承的正确性，常见错误有实体的名字一般是名词或动名词却用动词，联系的方向画反了，属性继承中的关键字未出现，继承的关系错误，联系未标注名称，关键字没有唯一性，未说明清楚实体的意义（是否是相交实体），属性合并不应该在需求理解阶段进行（例如把合同号和合同条目号合并）。不要把ER图当作流程图来绘制，注意实体识别的问题（概括性）。注意一般实体和分类实体的主关键字相同，每个分类实体应有不同于其他分类实体及一般实体的属性，应标明鉴别器属性。实体识别错误：1.实体要能用重叠量词形容，如意大利甲级联赛不是实体，2.实体应明晰关键字属性，3.各实体之间应有联系。一元联系产生的相交实体可以和其他实体有标定联系，同时一元联系产生的相交实体可以和原本的实体是非标定联系。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200424220149771.png" alt="image-20200424220149771"></p>
<h2 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h2><p>​        基本内容，数据库设计过程与设计方法，ER图/IDEF1X向关系模式的转换，不正确数据库设计引发的问题及其解决。数据库设计的四个过程。</p>
<p>​        数据库设计过程有，1.需求分析，要收集和理解需求的源，例如源可以是表格，2.概念数据库设计，用概念模型表达，最主要的是绘制ER图，3.逻辑数据库设计，最主要的是建立数据库的逻辑模型，最常见的是关系模型，要给出关系模式，4.物理数据库设计，建立物理模型，和具体的DBMS结合，包括物理组织，Create table，Create index。</p>
<p>​        需求分析。需求分析的结果是一份需求分析报告，要有基础数据库表，表之间的处理关系，形成“源”清单和“属性”清单，结合功能图和数据流图。“源”清单要有源名称，处理和存储要求，拥有的属性，要注意业务规则在表上的体现。“属性”清单要有名称，表述清楚属性的含义，要求。</p>
<p>​        概念数据库设计。要分析“源”表和“属性”表，要提交概念数据库设计报告，含有ER图，给出外部视图和概念视图。概念数据库设计有两种，1.先局部后全局，要找到每个部门的需求来设计外部模式，然后汇总再设计概念模式，2.先全局后局部，调研完成之后先设计全局模式，再设计外部模式。因此分为局部ER图和全局ER图，局部ER模式设计包括确定定义实体和联系，属性分配。全局ER模式设计要合并局部ER模式，检查并消除冲突，再优化。要消除的冲突有1.属性域冲突，2.属性取值单位冲突，3.结构冲突，4.命名冲突，同名异议，异名同义。绘制ER图有1.实体级图，2.键级图，只包括关键字，3.完整图。最常用的是键级图。概念数据库设计还要有“实体”清单，要有实体的中文名，英文名，对应的”源“序号，要有“实体”定义表，“实体-联系”矩阵，“实体-属性”矩阵（用于消除冲突）。概念数据库设计的过程，1.依据需求分析报告，2.识别实体与联系，3.绘制ER图/IDEF1X图，4.定义实体，联系及实体的属性构成（消除冲突），5.形成并提交概念数据库设计报告。</p>
<p>​        逻辑数据库设计。最主要的是给出逻辑模式，给出逻辑数据库报告，将ER图转换成逻辑模式，外模式和概念模式的定义。ER图如何转换，1.实体转换为关系，2.复合属性的转换，拆或者合并属性，3.多值属性，和关键字属性一起建新表，4.联系转换，一对一如果是部分参与，联系定义为新关系，关键字是参与的两个实体的关键字，如果一方是全部参与，另一方的关键字加入属性，一对多联系单方关键字加入多方的属性，多对多联系建新关系，关键字为双方实体的关键字，4.弱实体的转换，关键字是强实体的关键字和本身的区分属性，5.泛化和具体化，底层实体包括了高层的关键字，如果是全部转化可以不为高层实体建立关系，底层实体中可以包含高层实体所有的属性，6.多元联系的转化，1型转换，直接用联系各方的关键字作为主关键字，2型转换，可以增加区分属性，两种转换的区别是属性是否可以为空，使用哪种取决于是否必须参与，还可以转换为多个二元联系。IDEF1X转换只需要将实体转换为关系即可，分类联系可以和泛化和具体一样处理。</p>
<p>​        不正确设计数据库引发的问题。冗余，有受控冗余和非受控冗余，受控冗余是一种联系，非受控冗余是改变一个信息时有冗余数据同步更新问题。插入异常，信息不完整导致无法插入，删除异常，删除一些信息导致其他信息被删除。数据库规范设计需要分析数据库Table中的属性在取值方面有什么依存关系，数据库设计过程中应该遵循什么样的原则。数据库设计理论，1.数据依赖理论，2.关系范式理论，3.模式分解理论。不满足关系范式就要进行模式分析。逻辑数据库设计的步骤1.聚一聚概念数据库设计报告，2.ER图和IDEF1X图向关系模式的转换，3.检查逻辑数据库设计的正确性（数据库设计理论及其应用），4.定义全局模式和外模式，5.形成并提交逻辑数据库设计报告。</p>
<p>​        物理数据库设计。主要结合具体的DBMS，给出概念模式的物理描述，提交物理数据库设计报告。要DBMS选型，确定存储结构，设计完整性约束，建立索引，评估和设置磁盘空间，安全性控制，数据库备份。主要步骤1.依据逻辑数据库设计的报告，2.利用具体DBMS创建数据库/表，3.确定物理存储方式与存储空间，4.创建索引，视图等，5.形成并提交物理数据库设计报告。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200424232602164.png" alt="image-20200424232602164"></p>
<h2 id="函数依赖及其公理定理"><a href="#函数依赖及其公理定理" class="headerlink" title="函数依赖及其公理定理"></a>函数依赖及其公理定理</h2><p>​        主要介绍，什么是函数依赖，完全函数依赖与传递函数依赖，关于函数依赖的公理和定理，函数依赖集的最小覆盖。</p>
<p>​        什么是<strong>函数依赖</strong>。X属性集的值相等则Y属性集的值必定相等称为X函数决定Y，Y函数依赖X。函数依赖的分析取决于问题领域的限定和分析。设计关系模式的时候，除了属性集合还要给函数依赖。注意函数依赖提取时属性的前后顺序。非平凡的函数依赖，Y不属于X。X决定Y，称X为决定因素。X决定Y，有基于关系模式的，也有基于具体关系的。如果一个关系r的某属性集X，r中根本没有X上相等的两个元组存在，则X决定Y恒成立。对问题不同的理解可能有不同的函数依赖。</p>
<p>​        <strong>完全函数依赖</strong>。用R(U)表示关系模式，R是关系名称，U是属性全集。完全函数依赖是X的任意真子集都不被Y函数依赖，否则是<strong>部分函数依赖</strong>。部分函数依赖存在着非受控冗余。</p>
<p>​        <strong>传递函数依赖</strong>。在R(U)中，X决定Y，Y决定Z，Y不是X的子集，Z不是X或Y的子集，Y不决定X，则称Z传递函数依赖于X。传递依赖存在非受控冗余。X决定Y，Y决定Z，X决定Z是恒成立的，而X决定Z不一定是传递函数依赖，是符合传递率的。</p>
<p>​        相关概念。<strong>候选键</strong>，若K完全决定U，则称K为R(U)上的候选键。候选键满足唯一性（完全决定）和最小性。当有多个候选键的时候任意一个可以作为主键，包含在任意候选键中的属性称为主属性，其他属性成为非主属性。若R包含了K，R称为超键，即没有最小性。<strong>外来键</strong>，R(U)中的属性或者属性组合X不是R的候选键，但是是另一个关系的候选键，则称X为R的外来键，简称外键。<strong>逻辑蕴含</strong>，设F是R(U)中的一个函数依赖集合，若F能推导出X决定Y，则称X决定Y是F的逻辑蕴含。<strong>闭包</strong>，被F逻辑蕴含的所有函数依赖集合称为F的闭包。闭包中包括平凡函数依赖和决定空集。</p>
<p>​        关于函数依赖的公理和定理。表示关系模式的时候要给出R，U和F。阿姆斯特朗公理，A1<strong>自反率</strong>，属性组可以决定其子集，A2<strong>增广率</strong>，一个函数依赖两端各加上相同的属性组依然成立，A3<strong>传递率</strong>，X决定Y，Y决定Z，X决定Z恒成立。公理的作用是从已知的函数依赖推导出隐含的函数依赖。可用定义证明A1，A2，A3.<strong>合并率</strong>，X决定Y且X决定Z，则X决定YZ，<strong>伪传递率</strong>，若X决定Y且WY决定Z，则XW决定Z，<strong>分解率</strong>，X决定Y且Z属于Y，则X决定Z。<strong>引理3</strong>，X决定Y当且仅当X决定Y中的每一个属性。</p>
<p>​        <strong>属性（集）闭包</strong>。X关于F的属性（集）闭包是用阿姆斯特朗公理A1，A2，A3可从F导出的X决定A的A的集合。显然X属于X关于F的属性（集）闭包。可以用属性（集）闭包判断F是否包含特定函数依赖，X决定Y可从F有阿姆斯特朗公理导出，当且仅当Y属于X关于F的属性集闭包。属性集闭包可以证明阿姆斯特朗公理是有效的和完备的。</p>
<p>​        <strong>覆盖</strong>，R(U)上的两个函数依赖集合F，G，如果F的闭包等于G的闭包，则称F和G是等价的，也称F覆盖G或者G覆盖F。$F^+=G^+$的充要条件是$F\subseteq G^+ \land G\subseteq F^+$。计算一属性集X关于一组函数依赖F的属性闭包，对F中每个函数依赖如果右部是X的子集则将左部及其子集加入到X中，不断迭代直到X不发生变化。求属性闭包可以判断函数依赖是否在F中。</p>
<p>​        <strong>最小覆盖</strong>。每个函数依赖集F可被一个其右端至多有一个属性的函数依赖集G覆盖。最小覆盖，一个F称为最小覆盖，满足1.F中每个函数依赖的右部都是单个属性，2.去掉任何一个函数依赖都不和原来的F相等（不存在能够用其他函数依赖推导出来的函数依赖），3.每个函数依赖的右部不能被其真子集替代（每个函数依赖都是完全函数依赖）。每个函数依赖集F都有等价的最小覆盖$F’$。构造F的最小函数依赖，1.拆分右部，2.检查每个函数依赖是不是可以被其他的函数依赖推导出，3.消除非完全函数依赖的多余的属性。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200425162300144.png" alt="image-20200425162300144"></p>
<h2 id="关系范式"><a href="#关系范式" class="headerlink" title="关系范式"></a>关系范式</h2><p>​        主要讲了关系的第一范式，第二范式，第三范式和BC范式，多值依赖及其公理定理，第四范式。</p>
<p>​        <strong>第一范式</strong>。若R(U)中关系的每个分量都是不可分的数据项（值，原子），则称R(U)属于第一范式。即没有复合属性（同属性多列）和多值属性（同数据项多行）。不符合第一范式的情况，第一种情况将复合属性保留为一个属性或者拆开成多个属性，多值属性加上关键字组成新关系，第二种情况是引入OO数据模型，通过封装和对象将一组值封装成单一的对象。</p>
<p>​        <strong>第二范式</strong>。若R(U)属于第一范式且每一非主属性完全函数依赖于候选键，则称R(U)属于第二范式。注意完全函数依赖，如果存在不是完全函数依赖则可以分解模式。第二范式消除了非主属性对候选键的部分依赖。有部分依赖就有非受控冗余，拆开可以消除非受控冗余。要使满足第二范式就是要消除非主属性对候选键的部分函数依赖。</p>
<p>​        <strong>第三范式</strong>。若R(U)属于第二范式，且R中不存在候选键X可以被非主属性A传递函数依赖的，则称R(U)属于第三范式。消除传递函数依赖可以将关系模式按照传递函数依赖拆开，将每一个函数依赖单独组成一个关系，然后合并一些没有传递函数依赖的关系。</p>
<p>​        <strong>BC范式</strong>。若R(U,F)属于第一范式，对于F中的任意一条非平凡函数依赖都有右部含有候选键，则称R(U)属于BC范式。注意函数依赖里面可以有非主属性决定主属性的函数依赖。可以证明BC范式比第三范式更加严格。关系模式分解成BC范式，将左侧不含候选键的函数依赖单独组成一个关系，将包含候选键的组成一个关系，然后合并前者分解出的关系。</p>
<p>​        <strong>多值依赖</strong>。多值依赖，若X多值决定Y，则有如果同一X值有两个元组s，t有两种不同的Y值，则存在两个元组u，v拥有一方的Y值和另一方的U-X-Y值。多值依赖的特性，对于X的给定值，Y有一组与之对应（0或n个）且这组Y值与U-X-Y属性值独立，X，Y不必不相交，u，v可以与t，s相同，函数依赖是多值依赖的特例，X多值决定Y则X多值决定U-X-Y，如果U-X-Y是空集，则必有X多值决定Y。</p>
<p>​        <strong>第四范式</strong>。若R(U)属于第一范式，D是其上的一组依赖（函数依赖，多值依赖），对其中任意依赖，Y不为空集，Y不是X的子集，XY不为U（即为非平凡多值依赖），则必有X为超键，则称R(U)满足第四范式。第四范式消除了非主属性对候选键以外属性的多值依赖，如果有多值依赖则一定依赖于候选键。第四范式比BC范式更加严格。若R上仅存函数依赖，则BC范式和第四范式等价。<strong>弱第四范式</strong>，若R(U)属于第三范式，若R上的任何互补多值依赖X多值决定Y，XY不等于U，Y-X不等于空集和X多值决定（U-X-Y）中必有一个是函数依赖，则称R(U)是弱第四范式。弱第四范式不一定是BC范式，反之也不一定。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200425234722445.png" alt="image-20200425234722445"></p>
<h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><p>​        主要讲了模式分解存在什么问题，无损连接分解及其检验算法，保持依赖分解及其检验算法，关系模式无损连接或保持依赖的分解算法，数据库设计需要知道的。</p>
<p>​        模式分解存在的问题。<strong>模式分解</strong>，关系模式R(U)的分解是指用R的一组子集来代替它，子集中的关系的属性的并集等于原关系模式的属性集。投影连接$m_{\rho}(r)$是指按照模式分解投影之后再连接。模式分解需要关注，R与$\rho$数据内容方面是否等价，分解的无损连接性，R与$\rho$在数据依赖方面是否等价，分解的保持依赖性。引理1，$r\subseteq m_{\rho}(r)$，即<strong>模式分解的投影连接可能增加信息</strong>。引理2，模式分解的投影连接在分解的模式上的投影和原模式在分解的模式上的投影是一样的。引理3，投影连接的投影连接等于投影连接。另外一个问题是，<strong>分解后是否有约束丢失了</strong>。当模式不符合关系范式时，进行模式分解。</p>
<p>​        无损连接分解及其检验算法。<strong>无损连接分解</strong>，关系模式R的任意关系r的投影连接等于r，则称$\rho$是R相对于F的一个无损连接分解。无损连接性检验算法，构造$R_{\rho}$表，行是分解的模式$R_i$，列是属性$A_i$，属性属于分解的模式的交叉项写$a_j$，否则写$b_{ij}$，对每一条函数依赖，$R_i$的X集相同的，修改$R_i$中的Y集为相同的值，如果最后出现了一行都是$a_i$，则说明是无损连接，否则是有损连接。如果是把一个大的模式分解成两个小的模式，当且仅当$R_1$和$R_2$的交集决定$R_1$对$R_2$的差集或者$R_2$对$R_1$的差集在F的闭包中时，$\rho$是关于F无损连接的。无损连接分解的特性，无损连接分解之后的$R_i$再做无损连接分解，对于R也是无损连接分解的，无损连接分解增加一些子模式依然是无损连接分解。</p>
<p>​        保持依赖分解及其分解算法。<strong>保持依赖分解</strong>，对于关系R，$\pi_{R_i}(F)$的并集逻辑蕴含F的每个依赖，则称分解$\rho$保持依赖集F。保持依赖分解可能不是无损连接分解，无损连接分解也可能不是保持依赖分解。保持依赖性检验算法，按照定义检查，注意求X属性闭包的时候，要在有X的$R_i$中求解，即X必须是某一个关系模式的属性，求关于G的属性闭包，结果属性也必须是此关系模式的属性。</p>
<p>​        <strong>无损连接分解成BC范式的算法</strong>，对于模式分解$\rho$中每个不符合BC范式的模式，挑出一个不符合BC范式的函数依赖，拆成两个模式，一个模式里面只有X和Y，另一个有除了Y以外的所有属性，直到$\rho$中的每个模式都符合BC范式。这个算法不保证模式分解是保持依赖的。无损连接分解成BC范式的算法可以利用无损连接的检验算法证明。</p>
<p>​        <strong>关系模式保持依赖分解成第三范式</strong>，最简单的办法是对每一个函数依赖都建立一个关系模式，相同的X可以建立成同一个模式，R中不出现在F中的属性单独组成一模式，这种方式显然是保持依赖的。注意分解时需要F是函数依赖集的最小覆盖。</p>
<p>​        <strong>即保持依赖，又无损连接的分解</strong>。按照保持依赖的分解构造符合第三范式的模式分解，然后加入原关系模式R的候选键即可组成即保持依赖又是无损连接的符合第三范式的模式分解（或者分解后的关系模式集中有一个关系模式包含了候选键即可）。但这这种分解不一定是最小的可能的关系模式的集合，可以依次去掉一个关系模式再检查是否符合性质来得到最小集合。</p>
<p>​        <strong>无损连接分解成第四范式</strong>。设D为R上的依赖集（包括多值依赖），将含有X不是超键的依赖的关系模式分解成一个只包含X和Y的关系模式和一个包含Y-X的关系模式，直到所有关系模式符合第四范式。</p>
<p>​        <strong>连接依赖</strong>。被分解成n个关系模式并且无损连接性称为R满足n目连接依赖。记为$JD[R_1,…,R_n]$或者记为n-JD。多值依赖性是连接依赖的特例，2-JD，后者被认为是数据依赖的最一般形式，因为X多值决定Y，按照多值依赖分解成两个关系模式$\rho$，则$\rho$满足无损连接。JD是对关系的隐含约束，将影响元组的插入与删除。<strong>第五范式</strong>，当且仅当关系模式R的每个连接依赖均按其候选键进行连接运算时（均由R的候选键所隐含），则称R是第五范式的。第五范式消除了不按候选键连接的连接依赖，第五范式是第四范式的子集，也称为投影连接范式，简称PJNF。</p>
<p>​        数据库设计需要知道的。数据建模是从现实世界到信息世界（ER图），数据库设计是从信息世界到计算机世界（关系模式）。数据库设计理论主要用于判断什么样的设计是一个好的数据库设计，即怎样保证数据库设计的正确性。数据库理论包括数据依赖理论，关系范式理论，模式分解理论，最主要研究数据库当中的结构性约束，是属性在取值方面有什么依存关系，可以避免不一致性问题。数据依赖是用于判断是否符合关系范式，关系范式告诉我们有哪些关系范式，模式分解告诉我们当不满足关系范式时要分解成小的关系模式，分解的过程会存在什么样的问题，怎样保证正确的分解。第一范式包含第二范式包含第三范式包含BC范式包含第四范式包含第五范式。第三范式和BC范式较为接近，在设计上考虑到第三范式和BC范式就可以了。根本问题是哪些属性被组成一个关系。大关系模式查询很快，小关系模式查询较慢（连接运算），但是分解成小关系模式可以避免数据的不一致性，避免插入异常，删除异常，非受控冗余等，关系模式设计需要折中。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200427222119000.png" alt="image-20200427222119000"></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://1170300229.github.io/2020/03/30/data-base2/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://1170300229.github.io/2020/03/30/data-base2/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
