<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.png">
	<link rel="shortcut icon" href="/img/logo.png">
	
			    <title>
    Orange's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="orange">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">ORANGE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">创作</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/其他/">其他</a></li><li><a class="category-link" href="/categories/课堂笔记/">课堂笔记</a></li><li><a class="category-link" href="/categories/野生技能/">野生技能</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简介">
		                简介
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="朋友">
		                朋友
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/1170300229" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(/thumbnailImg/data-base2.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>数据库课堂笔记Ⅱ</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="数据库课堂笔记Ⅱ"><a href="#数据库课堂笔记Ⅱ" class="headerlink" title="数据库课堂笔记Ⅱ"></a>数据库课堂笔记Ⅱ</h1><h2 id="SQL语言与数据库完整性和安全性"><a href="#SQL语言与数据库完整性和安全性" class="headerlink" title="SQL语言与数据库完整性和安全性"></a>SQL语言与数据库完整性和安全性</h2><p>​        主要学习，完整性概念，规则，静态动态约束，安全性的概念，访问规则，权力与授权。</p>
<p>​        完整性的概念（正确的，有效的，一致的），有广义/狭义完整性。主要讨论语义完整性（狭义完整性）。完整性涉及到实体完整性，参照完整性，用户自定义完整性。数据库设计中也有完整性约束条件。引发完整性问题的是误操作，要方式和避免数据库中不合理数据的出现，DBMS防止语义不合理现象。DBMS通过完整性控制程序保证完整性（流程图）。</p>
<p>​        完整性约束规则是（O，P，A，R），O是数据集合，P是谓词，A是触发条件，R是响应动作。</p>
<p>​        完整性规则的分类。按约束对象分类，1.域完整性约束条件，对一列有影响，2.关系完整性约束条件，涉及到多列，或称表完整性。从约束来源分类，1.结构约束，来自模型的约束，函数依赖等，关心是否相等，是否允许空值，2.内容约束，来自用户的约束，主要是取值范围等。按约束状态分类，1.静态约束，任何时候都要满足，2.动态约束，是否能够发生改变。</p>
<p>​        静态约束，可以实现域完整性（列完整性）和关系完整性约束（表完整性）。根据约束规则，O是表或者列，A和R可以不用表达（默认）。Create Table有三种功能，定义关系模式，完整性约束和物理存储特性，可以同时定义列完整性和表完整性。<strong>Create Table列约束语法</strong>。给约束命名是为了方便撤销。search_cond是谓词。colname可以省略，意为外键和目标列名相同。CASEADE是删除此行。NOT NULL加UNIQUE就是主键/候选键。<strong>Create Table表约束语法</strong>。check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。可以用ALTER TABLE进行撤销或者追加。ADD DROP MODIFY，有些DBMS支持独立的追加约束，注意书写格式可能有些差异。</p>
<p>​        断言，可以实现完整性约束。断言是一个谓词表达式，表达了希望数据库总能满足的条件。表/列约束就是一些特殊的断言。断言多了会增加数据库负担。现在断言使用比较少。语法形式，Create Assertion assertion_name check()。注意exists。</p>
<p>​        动态约束，可以实现触发器。Trigger实际上是一段程序，可以在特定的时刻被执行。Create Trigger的语法。REFERENCING是变量声明。STATEMENT是对每一条SQL语句。BEFORE和AFTER分界线是是否修改了数据。</p>
<p>​        完整性总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200330235629352.png" alt="image-20200330235629352"></p>
<p>​        安全性的概念，免受非法，非授权用户的使用，泄露，更改或破坏。数据库安全性刊涉及许多方面。DBMS的安全机制，1.自主安全性机制：存取控制，在用户之间传播，2.强制安全性机制，数据和用户强制分类，3.推断安全性机制，4.数据加密机制。DBA需要划分好数据的安全级别以及用户的安全级别。</p>
<p>​        自主安全性机制。通过授权机制来实现。用户使用SQL-DCL来定义安全性控制规则。安全性控制程序（流程图）。</p>
<p>​        访问规则AccessRule（S，O，t，P），S是请求主体（用户），O是访问对象，t是访问权利，P是谓词。访问对象可大可小，属性/字段，记录/元组，关系，数据库，权利包括创建，增，删，改，查等，谓词是拥有权利需要满足的条件。S访问O是在P的条件下有t权利。有两种控制方法，按名控制安全性：存储矩阵（S，O，t，P），按内容控制，涉及到P。</p>
<p>​        两种自主安全性机制。1.存储矩阵，表示为主体-数据对象矩阵。大部分DBMS都是这种结构。算法是根据用户输入的Select-From-Where语句中使用的表或数据项进行检查，可以实现S，O，t，2.视图，定义用户可以访问的视图，限制用户对关系中某些数据项的存取，P可以放在视图中实现，视图也是一个新的对象O，可以实现S，O，t，P。</p>
<p>​        SQL语言实现自主安全性。数据库安全性属于DCL。用户级别：超级用户（DBA），账户级别（程序员用户），关系级别（普通用户）。权利级别有1.Select，读，2.Modify，更新，Insert，Update，Delete，3.Create，创建，Create，Alter，Drop，级别高的拥有级别低的权利。<strong>SQL授权命令GRANT</strong>。WITH GRANT OPTION是否允许传播被授权的权利。ON后面可以接表后者视图。public是公开的。REVOKE是收回授权。</p>
<p>​        授权过程，1.DBA创建DB，创建账户，2.分配用户账户级别的权利，3.用户创建基本表或视图，并拥有该表/视图的所有权利，4.传播权利。传播范围包括两个方面，水平传播数量和垂直传播数量，前者是一层传播了多少个用户，后者是多少层。有些系统可能控制传播范围。有重复授权问题。</p>
<p>​        强制安全性，对数据对象和用户进行安全性分级（绝密，机密，可信，无分类）。访问规则是高级别用户可以访问低级别数据对象，反之不能，高级别用户不能改低级别数据，除非提升数据级别。强制安全性的实现，定义关系模式时需要引入安全性分级特性或称分类特性。<strong>分类特性定义语法</strong>。强制安全性机制是的关系形成为多级关系，需要特殊的处理技巧。</p>
<p>​        安全性总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200330235504023.png" alt="image-20200330235504023"></p>
<h2 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h2><p>​        主要讲了嵌入式SQL语言的概述，变量声明和数据库连接，数据集与游标，可滚动游标与数据库的增删改，状态捕获及错误处理机制。</p>
<p>​        嵌入式SQL语言概述。优点，记录集合操作，非过程性操作，一条语句可以实现复杂的查询效果。缺点是对普通用户复杂，一条SQL不能完成所有操作，在SQL语言检索结果上进行处理。高级语言+SQL语言是解决方案，其中高级语言称为宿主语言。嵌入式SQL和交互式SQL语言不太一样，1.有引导词exec sql，可以预编译，2.增加了into，3.：的引进。高级语言（语句）和嵌入式SQL语句和DBMS和DB的关系图，八个问题，1.连接问题，2.宿主程序的变量传递，3.SQL语句的执行，4.SQL检索结果船体，5.静态SQL的常量替换为变量，6.是否发生错误，7.动态SQL，已知表名和字段，8.动态SQL，未知表名和字段。</p>
<p>​        变量声明和数据库连接。有：的是高级语言程序变量，可以使用begin declare section;end declare section;的语法声明。注意数据库中宿主语言字符串可能长度多一，因为结束符\0，有些宿主程序变量类型自动转换只有部分DBMS支持。连接语法，exec sql connect to as user或exec sql connect to default，注意不同DBMS可能语法不一致。断开数据库连接语法，exec sql disconnect或exec sql disconnect current，注意不同DBMS可能语法不一致。SQL执行的提交和撤销语法。</p>
<p>​        提交和撤销。事务，是一个存取或改变数据库内容的程序的一次执行，一条或多条SQL语句的一次执行被看作一个事务。事务一般由应用程序员提出，结束时需要提交（生效）或者撤销（无效，恢复至原状态）。事务从微观角度是一种控制数据库的手段（具体定义），以便数据库能够提供<strong>一致性</strong>状态转换的保证（要么全部执行，要么全不执行）。事务的特性，ACID，原子性，一致性，隔离性（处理并发），持久性。事务的第三个定义，具有ACID特性的若干数据库基本操作的组合体被称为事务，事务处理是DBMS的核心技术。</p>
<p>​        嵌入式SQL语言的例子。sqlca是通讯区，先声明使用sqlca，然后声明一些变量，然后设置动态错误捕获的语句，连接数据库，再实现查询并提交，再断开数据库连接并结束，可能会跳到notfound和report_error（需要声明），再Rollback并断开连接。</p>
<p>​        数据集和游标，解决了问题3，4，5。检索的单行结果，可将结果直接传到宿主程序的变量中。into后面加上宿主程序的变量。如果是多行结果，则需要用游标，是指向结果集合的指针，使用fetch into可以读取结果。游标使用要先定义，再执行，然后一条一条处理，最后关闭，注意游标的语法。游标在open（执行）的时候才真正执行，可以多次打开，多次记录。</p>
<p>​        游标应用示例。如果出错了需要Rollback。定义中可能定义只读的（For read only），或者更新。打开和关闭的语法。</p>
<p>​        可滚动的游标和数据库的增删改。标准的游标只能从上往下读取。ODBC提供了可滚动的游标，许多DBMS不能支持可滚动游标，但是可以通过ODBC实现。在声明游标的时候可以声明是否为可滚动游标，FETCH后面可以选择如何移动。可滚动游标上下界分别是BOF和EOF。</p>
<p>​        数据库记录的删除有查找删除和定位删除。查找删除可以通过Select-From-Where查找删除，定位删除是通过游标删除。更新也有查找更新和定位更新。插入只有一种类型。注意执行一次fetch只能取一次值。</p>
<p>​        状态捕获及错误处理机制。解决问题6。状态是指嵌入式SQL语句的执行状态，如出错状态。状态捕获由三部分组成1.设置SQL通信区，2.设置状态捕获语句，3.状态处理语句。SQLCA是一个被声明过的内存信息区，其中成员变量用来记录SQL语句执行的状态，是DBMS与宿主程序之间交流的桥梁。</p>
<p>​        状态捕获语句的语法。whenever是一个“条件陷阱”，<strong>生效范围是之后的所有SQL调用，直到出现相同条件的whenever为止（注意GOTO）</strong>。状态捕获中的状态有SQLERROR（是否有SQL语句出错），NOT FOUND（没有找到相应记录），SQLWARNING（警告），都对应着whenever后面的condition。action中有CONTINUE，GOTO，STOP，DO，CALL（DO和CALL都是调用函数）。状态捕获语句容易引发无限循环，为了避免无限循环注意添加CONTINUE。DBMS系统记录状态信息的三种方法，1.sqlcode，等于0是成功，小于0是出错，大于0是警告，2.sqlca.sqlcode，3.sqlstate，如果不需要知道错误类型只需要知道状态（隐式状态处理），如果需要则要知道sqlcode（显式状态处理），注意显式状态处理的位置和错误捕获的作用域。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200401220109052.png" alt="image-20200401220109052"></p>
<h2 id="嵌入式SQL语言之动态SQL"><a href="#嵌入式SQL语言之动态SQL" class="headerlink" title="嵌入式SQL语言之动态SQL"></a>嵌入式SQL语言之动态SQL</h2><p>​        主要讲了动态SQL的概念和作用，SQL语句动态构造，动态SQL执行方式，数据字典与SQLDA，ODBC和JDBC的简介。</p>
<p>​        动态SQL的概念。动态SQL解决了问题3和7。静态SQL是SQL语句已经写好了的，只需要传入高级语言中的一些参数。动态SQL中SQL语句是一个字符串来被执行，通过execute immediate语法。如何设计用户的操作界面，可以遵循QBE的思路（转换图），变成一种界面操作表单型语言。</p>
<p>​        SQL语句的动态构造。用户在界面输入筛选条件。动态构造字符串作为SQL语句。dtoa函数是用来转换为字符串类型。构造动态SQL语句的时候要写好基本部分，SQL中的字符串需要加引号，添加逻辑运算符，数值变量转换为字符串。trim是去掉两边的空格，len是求长度。</p>
<p>​        动态SQL有两种执行方式，1.立即执行，运行时编译并执行，是完整的语句，2.Prepare-Execute-Using语句，PREPARE语句先编译，EXECUTE语句执行时用USING传入动态参数，实现延迟执行，通常作为SQL语句的字符串中有对高级语言的变量的引用。一种构造的字符串SQL内部没有“变量”参数，一种构造的字符串SQL内部有“变量”参数。</p>
<p>​        数据字典与SQLDA。解决问题8。数据字典，又称为系统目录，目录表，系统视图，本身是一些表和视图的集合，存储了系统数据的集合，是元数据，即关于数据的数据。不同的DBMS存储方式不一样，但会有一些信息对DBA公开，DBA可以使用一些特殊SQL命令来检索。</p>
<p>​        数据字典的内容构成，通常存储的是数据库和表的元数据，即模式本身的信息，1.与关系相关的信息，如关系的名字，属性名及其类型，视图的名字及其定义，完整性约束，2.用户与账户信息，密码，3.统计与描述性数据，4.物理文件组织信息，5，索引相关信息。</p>
<p>​        数据字典的结构。可能的字典数据结构，有关系/属性/用户/索引/视图元数据（表）。X/Open标准中的目录表Info_Schem.Tables，该表中的每一行是一个已经定义的表的有关信息。表的模式名是指模式名+表名，这里模式是指每个用户有一个模式，数据库拥有者为默认的模式名，可以使用Create Schema语句来创建模式，可以让不同的用户有相同的表名。Oracle数据字典由视图组成，有三种不同的形式，三种前缀是UESER_，ALL_，DBA_，由三个前缀+TABLE组成，是有关表的信息，由三个前缀+Columns组成，是有关列的信息。Oracle还定义了其他视图，也可以使用SQL*PLUS进行交互式访问。</p>
<p>​        更为复杂的动态SQL。用户要确定读哪个表的时候需要从数据字典中选出表。SQLDA称为SQL描述区，存储的是数据库表的定义信息，是一种内存的数据结构，内可装载关系模式的定义信息，不同DBMS提供的SQLDA格式并不是一致的，SQLCA存储的是SQL语句和DBMS交互的状态信息。</p>
<p>​        什么是ODBC。是不同语言的应用程序与不同数据库服务器之间通讯的标准，包括一组API，通过调用ODBC API，可以是实现与数据服务器的连接，向数据库服务器发送SQL命令，处理返回的结果。具体的DBMS提供一套驱动程序，Driver库函数供ODBC调用，以便实现数据库与应用程序连接，ODBC可以配合很多高级语言使用。ODBC对应用程序提供统一的接口。</p>
<p>​        应用程序如何通过ODBC连接数据库服务器。当应用程序调用ODBC API时，ODBC API会调用具体的DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯。ODBC应用程序首先要分配一个SQL环境再产生一个数据库连接的句柄。连接举例。应用程序使用SQL ExecDirect向数据库发送SQL命令，使用SQLFetch获取产生的结果元组，使用SQLBindCol绑定C语言变量与结果中的属性。ODBC也可以对动态SQL预编译，动态参数传递，获取元数据等，有些可以自动提交，但是有些需要显式地提交和撤销。</p>
<p>​        什么是JDBC。JDBC是Java版的JDBC。包括两个部分1.核心API，2.扩展API，包括连接池，分布式事务等。JDBC的核心类1.DriverManager，处理驱动的调入并且对产生新数据库连接提供支持，2.Driver，通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动，3.Connection，代表对特定数据库的连接。Satement是对特定数据库执行SQL，PreparedStatement用于预编译，CallableStatement是对内嵌过程的调用，ResultSet是返回的结果。</p>
<p>​        JDBC使用的基本过程，1.打开连接，2.创建“Statement”对象，设置查询语句，3.使用Statement执行查询，4.得到结果，5.处理错误的额外机制（具体语法）。Update，Execute query and fetch and print results。</p>
<p>​        嵌入式语言，ODBC和JDBC的比较。嵌入式语言，建立数据库连接-声明一个游标-打开游标-获取一条记录-关闭游标-断开数据库连接，以语句为中心。ODBC是以API函数来执行的，建立数据库连接-分配语句句柄-用句柄执行SQL-建立高级语言变量与句柄属性的对应-获取一条一条记录-释放语句句柄-断开数据库连接，以函数操作SQL。JDBC，建立数据库连接-创建语句对象-用语句对象执行SQL，并返回结果对象-从结果对象获取一条一条记录-提取对象的属性值传给高级语言变量-释放语句对象-断开数据库连接，以对象为中心。基于ODBC/JDBC的数据库访问，和普通的数据库访问的差别，对多个数据库系统进行进一步抽象。</p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200403171351470.png" alt="image-20200403171351470"></p>
<h2 id="数据建模：思想与方法"><a href="#数据建模：思想与方法" class="headerlink" title="数据建模：思想与方法"></a>数据建模：思想与方法</h2><p>​        主要讲了理解数据建模与数据库设计。理解并掌握E-R模型/IDEF1X模型，能够用E-R/IDEF1X模型准确理解现实世界并进行数据库设计，理解并掌握数据库设计理论，能够运用数据库设计理论分析数据库设计的正确性。</p>
<p>​        这一讲主要讲了基本思想，ER模型，Chen方法，Crow‘s foot方法，案例，设计中的抽象。</p>
<p>​        为什么要数据建模与数据库设计。成功的软件开发有需求的理解与表达。数据需求的理解与表达是非常重要的。</p>
<p>​        数据模型和概念模型。表达计算机世界的模型称数据模型，表达信息世界的模型称概念数据模型，信息世界是对现实世界的理解与抽象（<strong>流程图</strong>）。抽象是分层次的，现实世界到观念世界/信息世界到数据世界/计算机世界，数据世界/计算机世界包括逻辑层和物理层。从待表达的问题到概念模型到数据模型。<strong>数据建模</strong>指的是从待表达的问题到概念模型，<strong>数据库设计</strong>指的是从概念模型到数据模型。</p>
<p>​        什么是抽象。抽象是理解-区分-命名-表达。现实世界需要理解，理解的标志是区分，区分的标志是命名，抽象的最终结果是正确的表达。</p>
<p>​        E-R模型。E-R模型的基本观点，世界是由一组称作实体的基本对象和这些对象之间的联系构成的。建模思想是理解-区分-命名，需要区分及命名哪些要素，表达方法是用不同的图形表达被区分的不同要素。E-R模型给出了基本概念，实体，属性，联系，关键字/码。抽象的概念赋予具体的语义就是建模。</p>
<p>​        实体。实体是客观存在并可相互区分的事物，实体有类（实体，实体的型）和个体（实体的实例，实体的值）的概念。一类实体具有相同或相似的特性。</p>
<p>​        属性。实体所具有的某一方面的特性。实体用属性来刻画。实体由实体的型来刻画，实例由实体的值来刻画。属性有<strong>单一属性和复合属性</strong>。复合属性比如说家庭住址包括了省份和详细住址，在关系模型中，复合属性一定要转化为单一属性（关系的第一范式）。属性也有<strong>单值属性和多值属性</strong>。属性还有<strong>可空值属性和非空值属性</strong>。属性还有<strong>导出属性</strong>。实体还有特殊的属性，这个特殊的属性称为关键字/码，实体中能够用其值唯一区分开每一实例的属性或属性组合。</p>
<p>​        联系，指一个实体的实例和其他实体实例之间所可能发生的联系。联系的元/度，指参与联系的实体的数目。联系也是需要处理和存储的。实体是相对稳定的，联系可以是多样化的。一元联系，同一个实体中的实例之间发生的联系，为了区分引入角色。角色是实体在联系中的作用称为实体的角色，当同一实体的不同实例参与联系时，为区别各实例参与联系的方式，需要显式指明其角色。</p>
<p>​        联系与联系的基数。对于联系还有一对一的联系，一对多的联系和多对多的联系。判断是其中一个实体可以对多少个另一实体的。联系的基数，实体实例之间的联系的数量。常见的映射基数如上，有一对一，一对多，多对多几种情况。进一步，联系的基数还要区分0个，1个，不定数目的多个还是固定数目的多个。最小基数到最大基数之间用并排的两个点连接，一对一，一对多，多对多是用冒号。完全参与联系，该端实例至少有一个参与到联系中，最下基数为1，部分参与联系是0。区分是为了空值的处理，是否允许有空值。</p>
<p>​        Chen方法，E-R模型模型的图示化表示方法，还有Crow’s Foot方法，IDEF1X方法（工程化方法）。Chen方法用矩形框表达实体，用椭圆表示属性，双线椭圆表示多值属性，虚线表示导出属性，下划线表示关键字/码，直线表示连接实体和属性，菱形框表示联系，直线表示连接实体与联系，直线表示连接联系和属性，标有相同数字是复合关键字，标有不同数字是多组关键字。不同的联系的表达方法，1有箭头，多无箭头，完全参与是双直线，部分参与是单直线，也可以在直线上标注0，1，n和m，最少基数和最大基数。联系也需要命名和表达。联系也可以有属性，每个实体至少要给出关键字，联系与实体间连线不是随意画的，其代表实体的关键字要作为联系的属性。直线上标记有文字是联系的角色。</p>
<p>​        用Chen方法建模案例。1.理解需求，寻找实体，实体是能够用重叠量词形容的，2.用属性刻画每一个实体，3.确定每一个实体的关键字/码，4.数据建模的重点是分析实体之间的联系，标注联系属性，基数，5.检查是否覆盖了需求，E-R图是对需求的理解与表达，要覆盖需求，E-R图的绘制要符合规范，Chen方法。</p>
<p>​        Crow‘s foot方法。实体是矩形框，实体的名称卸载横线上面。属性，在实体框横向下面，关键字是在属性下加下划线。比Chen方法好的地方在于省空间。联系，菱形框表示，也可以将菱形框省略而直接以联系名来替代。联系的基数，使用不同的联系连接地方的图形表示。图形表达业务规则。一元联系的表达，角色可以写在联系的横线上，使用虚线连接。</p>
<p>​        Crow’s foot方法示例，E-R图是对需求的理解与表达，要覆盖需求，E-R图的绘制要符合规范，Crow’s foot方法。</p>
<p>​        数据库设计的抽象。什么是信息，信息是现实世界中事物在人们头脑中的一种反映。数据库设计往往因为忽视了信息（之间联系）的细致分析而造成设计失误，数据库设计能力的高低往往体现在信息（及其联系）的正确分析上，体现在理解现实世界能力的高低。三个世界与多层抽象，现实世界到信息世界到计算机世界。型与值，是基本的抽象。进一步还有型与“型的型”，“型的型”例如属性。现实层到抽象层到逻辑层到物理层。越抽象，语义信息越少，概括性越高，越反映共性信息，表征的范围也越大。检验抽象正确性的方法，能够依据现实抽象出来（抽象化），同时也能依据抽象的信息和抽象规则还原为被抽象对象（具体化）。</p>
<p>​        数据模型，不同范围的人对现实世界中事物的描述和抽象可能是不同的，为了避免认识上的不一致，需要统一的概念与统一的表达方法，统一是为了信息交流，信息共享。数据模型是一组相互关联且已严格定义的概念集合，是用于刻画或描述现实世界，信息世界或计算机世界的模型。表达计算机世界的模型称数据模型，表达信息世界的模型称概念数据模型，简称概念模型。数据库的抽象，将现实世界转化为概念方法，转化为表/视图。分层级抽象，待表达的问题到概念级抽象到实现级抽象。另一种抽象，方法论，用一般性方法指导抽象，抽象过程，抽象结果的表达方法。</p>
<p><img src="/2020/03/30/data-base2/image-20200408221151538.png" alt="image-20200408221151538"></p>
<p>​        建模的不同层次，有模型与元模型，模型（型）与实例（值），注意层次图。</p>
<p><img src="/2020/03/30/data-base2/image-20200408222439561.png" alt="image-20200408222439561"></p>
<p>​        本讲总结。</p>
<p><img src="/2020/03/30/data-base2/image-20200408222704652.png" alt="image-20200408222704652"></p>
<h2 id="数据建模：工程化及案例分析"><a href="#数据建模：工程化及案例分析" class="headerlink" title="数据建模：工程化及案例分析"></a>数据建模：工程化及案例分析</h2><p>​        主要讲了IDEF1X图。</p>
<p>​        什么是IDEF1X。IDEF1X是IDEF标准之一，IDEF0是功能模型的描述方法，IDEF1是信息模型的描述方法，IDEF2是动态模型的描述方法。后来IDEF被扩展成IDEF1X。后来IDEF的发展还有IDEF3，IDEF4，IDEF5。IDEF1X是E-R模型扩充语义而形成的，或者说IDEF1X是E-R图的细化。IDEF1X是一种进行数据建模或数据库设计的工程化方法。IDEF1X中的重要概念，实体被细分为独立实体（强实体），从属实体（弱实体），联系被细分为可标定连接联系，非标定连接联系，分类联系，非确定联系，属性被细分为属性，主关键字/主码（主属性），次关键字/候选码，外来关键字/外来码（外来属性）。IDEF1X是一种图示化，工程化的建模方法，也可以被认为是E-R模型的第三种表示方法。</p>
<p>​        IDEF1X两种实体的区分。实体，一个“实体”表示一个现实和抽象事物的集合，这些事物必须具有相同的属性和特征，这个集合的一个元素就是该实体的一个实例。实体被区分为独立实体和从属实体，在扩展E-R图中，独立实体又称强实体，从属实体又称弱实体。独立实体是指一个实体的实例都被唯一标识而不决定于它与其他实体的联系。</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://1170300229.github.io/2020/03/30/data-base2/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://1170300229.github.io/2020/03/30/data-base2/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
