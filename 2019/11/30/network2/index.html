<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.png">
	<link rel="shortcut icon" href="/img/logo.png">
	
			    <title>
    Orange's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="orange">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">ORANGE</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">创作</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/其他/">其他</a></li><li><a class="category-link" href="/categories/课堂笔记/">课堂笔记</a></li><li><a class="category-link" href="/categories/野生技能/">野生技能</a>
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简介">
		                简介
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="朋友">
		                朋友
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/1170300229" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url(/thumbnailImg/network2.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>计算机网络笔记Ⅱ</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="计算机网络笔记Ⅱ"><a href="#计算机网络笔记Ⅱ" class="headerlink" title="计算机网络笔记Ⅱ"></a>计算机网络笔记Ⅱ</h1><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><p>​        网络层提供的服务：从发送主机获得数据段并将数据段封装到数据报中，在接收主机向传输层交付数据段，每个主机和路由器都运行网络层协议，路由器检验所有穿越它的IP数据报的头部域。</p>
<p>​        网络层的核心功能：转发与路由，连接建立（不是所有网络，ATM网络就需要连接建立）。转发：将分组从路由器的输入端口转移到合适的输出端口。路由：确定分组从源到目的经过的路径。路由算法确定路由表。连接建立：数据分组传输之前两端主机需要首先建立虚拟/逻辑连接（网络设备如路由器参与连接的建立）。对比网络层连接和传输层连接：网络层连接是两个主机（路径上的所有路由器等网络设备参与其中），传输层连接是两个应用进程之间（对中间路由器透明）。</p>
<p>​        网络层提供的服务。如下图所示，Internet的网络层是提供“尽力服务”。总结网络层提供的服务类型分为无连接服务：不事先为系列分组的传输确定传输路径，即每个分组的传输路径也有可能不一样，有可能造成乱序等情况，典型为数据报网络，连接服务：所有分组沿着相同的路径进行传输，可以保证分组的顺序，需要拆除连接，典型的有虚电路网络。</p>
<p><img src="/2019/11/30/network2/image-20191130215511130.png" alt="image-20191130215511130"></p>
<h3 id="虚电路网络与数据报网络"><a href="#虚电路网络与数据报网络" class="headerlink" title="虚电路网络与数据报网络"></a>虚电路网络与数据报网络</h3><p>​        数据报网络与虚电路网络都是典型的分组交换网络。数据报网络提供网络层无连接服务，虚电路网络提供网络层连接服务。</p>
<p>​        虚电路网络，一条从源主机到目的主机类似于电路的路径（逻辑连接）。是分组交换，每个分组的传输利用链路的全部带宽。源到目的路径经过的网络层设备共同完成虚电路功能。通信过程：<strong>呼叫建立，数据传输，拆除呼叫</strong>。每个分组携带虚电路标识（VCID），而不是目的主机地址。虚电路经过的每个网络设备都要维护每条经过它的虚电路的连接状态，链路，网络设备资源（如带宽）可以面向VC进行预分配。虚电路是从源主机到目的主机的一条路径，<strong>VCID沿路每段链路一个编号，即同一条虚电路不同段的虚电路号可能不一样</strong>，沿某条虚电路传输的分组携带的是VCID。路由器转发分组时依据转发表改写/替换VCID。VC转发表记录：输入接口，输入VC，输出接口，输出VC。虚电路信令协议（signaling protocols），用于VC的建立，维护与拆除，路由选择，应用在ATM，帧中继（frame-relay）网络等。虚电路通信建立过程：1.初始呼叫，2.呼叫到达，3.接收呼叫，4.呼叫建立，5.数据流开始，6.接收数据。</p>
<p>​        数据报网络。数据报网络在网络层无连接，每个分组都要携带目的地址，每个分组独立选路。数据报转发表中针对地址范围转发（聚合转发表入口）。转发表有最长前缀匹配优先的原则，即在检索转发表时，优先选择与分组目的地址匹配前缀最长的入口。</p>
<p>​        数据报网络和VC网络的对比。Internet网络是数据报网络，ATM网络是VC网络。</p>
<p><img src="/2019/11/30/network2/image-20191130225636636.png" alt="image-20191130225636636"></p>
<h3 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h3><p>​        Internet网络层。主机，路由器网络层主要功能如下图所示。主要有路由协议，IP协议和ICMP协议。</p>
<p><img src="/2019/11/30/network2/image-20191201141809946.png" alt="image-20191201141809946"></p>
<p>​        IP数据报的格式如下所示。首部 通常大小为20个字节（无选项字段）。版本号：指示是IPv4和还是IPv6。首部长度：以4字节为单位，实际上首部长度指示了头部长度一共有多少行（一行4字节）。服务类型：后来改名为区分服务，用来区分不同的服务，需要网络提供区分服务时使用，一般情况下不适用，通常IP分组的该字段（第2字节）的值为0。总长度：整个IP数据报的长度（包括数据部分，以字节为单位），因此最大IP分组的总长度为65535B，最小IP分组的总长度为20B，IP分组可以封装的最大数据：65515B。标识，标志位，片偏移。TTL：IP分组在网络中可以通过的路由器数（跳步数），每次路由器转发一次分组，TTL减一，如果TTL为0路由器将丢弃该分组，同时发送一个ICMP报文。协议：IP分组封装的是哪一个协议的数据报，实现了复用/分解，<strong>TCP为6，UDP为17，ICMP为1</strong>。首部校验和：仅计算IP分组的首部，计算的时候这个字段被置为全0，计算方法和UDP一样，<strong>检验的时候也是同种算法，最后的结果应该是全1，并且首部校验和是逐跳计算的</strong>。选项字段：范围在1~40字节之间，主要用于携带安全，源选路径，时间戳和路有记录等内容，实际上很少被使用，填充用来将首部长度填充为4字节的倍数。</p>
<p><img src="/2019/11/30/network2/image-20191201141947539.png" alt="image-20191201141947539"></p>
<p>​        IP分片。MTU，最大传输单元，由于链路的数据帧有可封装数据的上限，因此有MTU。当大IP分组向较小MTU链路转发时，可以被“分片”。IP分组如果不允许分片则路由器会把IP分组丢弃并发送ICMP报文。路由器不组装分片，目的主机组装IP分组（因为防止组装之后再次分片）。分组之间通过总长度，标识，标志位，片偏移来组装分片。目的主机等待一段时间，如果没有收到所有的IP分片则会丢掉所有的IP分片。<strong>标识</strong>的生成通过计时器，每生成一个分组就加一，标识还通过源IP地址，目的IP地址，协议等字段使标识唯一。<strong>标志位</strong>有DF和MF，DF表示是否禁止分片，MF表示是否是最后一片。<strong>片偏移</strong>有13位，代表一个IP分组分片封装原IP分组数据的相对偏移量，<strong>即这个分片之前的分片的数据部分的长度，片偏移字段以8字节为单位。</strong>即要求所有的分片的数据都是8字节的倍数。通常分片时，除最后一个分片，其他分片均为MTU允许的最大分片。计算每段可以存放的最大数据量需要MTU减去20字节的头部再约到8的倍数。注意片偏移都是针对数据部分而言的，注意总长度是包括头部的，并且第一个字节的编号为0。</p>
<p>​        IP编址。<strong>接口</strong>，定义为主机/路由器与物理链路的连接，并且实现了网络层的功能。路由器通常有多个接口，而主机通常只有一个或两个接口。<strong>每个接口都有一个IP地址。</strong>IP地址分为4个8bit的数，称为点分十进制的形式。为了方便路由（随意分配IP地址将导致路由表非常复杂），需要IP子网。即IP地址又可以被划分为网络号和主机号。因此在Internet网络分配IP地址，需要遵循基本原则，即要保证分配到某个地区的接口的IP地址的网络号是相同的。具有相同网络号的接口称为<strong>IP子网</strong>。同一个IP子网中不会有两个接口的物理链路要跨越路由器（三层网络设备）。</p>
<p><img src="/2019/11/30/network2/image-20191201163720577.png" alt="image-20191201163720577"></p>
<p>​        注意下图一共有6个IP子网（可以通过去掉所有的三层即以上网络设备来看剩下的接口）。</p>
<p><img src="/2019/11/30/network2/image-20191201163851101.png" alt="image-20191201163851101"></p>
<p>​        有类IP地址（有类编址）。采用的是二分法。计算能区分网络数要减去首部固定的比特位的影响。A类，B类，C类地址都是单播地址。D类地址不区分网络号和主机号，是多播地址（组播地址），D类地址用来命名标识互联网中的一组主机，任意一台主机都可以加入任意一个多播地址，一台主机可以随时加入或离开一个组播组，也可以同时属于多个组播组，D类地址只能作为IP分组的目的地址。E类地址作为保留地址。A类，B类，C类一共占87.5%，是可分配的。</p>
<p><img src="/2019/11/30/network2/image-20191201170528372.png" alt="image-20191201170528372"></p>
<p>​        同时下面特殊IP地址不能成为主机接口的IP地址。主机不明确自己的IP地址的时候使用全0。本网广播地址也称为受限网络地址。A类网络中网络号全0和全1都不能分配给主机作为IP地址。环回测试表示IP分组进入网络层之后不会离开本机，用于测试协议等。</p>
<p><img src="/2019/11/30/network2/image-20191201170726493.png" alt="image-20191201170726493"></p>
<p>​        私有地址。这些地址只用于内部网络。在公共互联网上这些地址是无效的。</p>
<p><img src="/2019/11/30/network2/image-20191201171934172.png" alt="image-20191201171934172"></p>
<p>​        IP子网划分与子网掩码。子网划分用于区分一个IP子网更小范围网络（子网），做法是将IP地址划分为网络号，子网号和主机号。子网号是在原主机号中划分的。路由器通过子网掩码来确定子网范围。例如A网的默认子网掩码为255.0.0.0，B网的默认子网掩码为255.255.0.0，C网的默认子网掩码为255.255.255.0。<strong>子网地址+子网掩码确定子网大小。</strong>路由器将IP分组的目的IP地址与子网掩码按位与运算提取子网地址。<strong>子网地址的描述形式为子网地址+子网掩码。</strong>注意区分地址范围和可分配地址范围。</p>
<p><img src="/2019/11/30/network2/image-20191201172750917.png" alt="image-20191201172750917"></p>
<h3 id="CIDR与路由聚合"><a href="#CIDR与路由聚合" class="headerlink" title="CIDR与路由聚合"></a>CIDR与路由聚合</h3><p>​        无类域间路由（CIDR）。消除了传统的A类，B类，C类地址界限。网络号+子网号称为网络前缀，可以任意长度。同时融合了子网地址与子网掩码，方便网络划分。无类地址格式：a.b.c.d/x，其中x为前缀长度。CIDR可以提高IPv4地址空间分配效率，可以提高路由效率，如将多个子网聚合为一个较大的子网（超网），以及路由聚合。在互联网的主干网络上，充分使用CIDR可以减少40%~70%路由表，对路由效率的提高非常明显。层级编址使得路由信息通告更高效。路由中有黑洞现象，即子网中下属的某些子网不在这个子网内，可以通过最长前缀匹配优先的原则保证正确性。</p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>​        一个主机获得IP地址的途径：1.硬编码，即静态配置，需要配置IP地址，子网掩码，默认网关，域名服务器，默认网关表示IP数据报要离开子网时应该送到哪个接口上进行转发，域名服务器，域名解析的查询应该发送到的服务器，2.动态地址配置，在Internet中通常使用动态主机配置协议，可以从服务器动态获取IP地址，子网掩码，默认网关，域名服务器的名称与IP地址，是“即插即的”，允许地址重用，支持在用地址续租，支持移动用户加入网络。</p>
<p>​        主机广播”DHCP discover“（发现报文），DHCP服务器利用”DHCP offer“（提供报文）进行响应，主机请求IP地址“DHCP request”（请求报文），DHCP服务器分配IP地址“DHCP ack”（确认报文）。DHCP是C/S结构，应用进程，在应用层实现，请求报文封装到UDP数据报中，采用IP广播，实际中都映射为链路层广播。</p>
<p>​        具体过程如下图所示，注意客户端的端口号是68，服务器的端口号是67。DHCP request报文中目的地址也是广播地址，原因是可能存在多个DHCP服务器。DHCP ack中包含了子网掩码，默认网关，域名服务器等。</p>
<p><img src="/2019/11/30/network2/image-20191201183026847.png" alt="image-20191201183026847"></p>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>​        实现NAT，需要子网中接入互联网的路由器至少有一个合法的公网IP（NAT IP地址），并且路由器能够实现NAT，如果内网主机需要和互联网进行通信则需要转换为合法IP，不同的主机发送到互联网上的信息通过端口号来区分。</p>
<p>​        NAT的动机：1.只需/能从ISP申请一个IP地址，2.本地网络设备IP的变更，无需通告外界网络，3.变更ISP时，无需修改内部网络设备IP地址，4.内部网络设备对外界网络不可见，即不可直接寻址。</p>
<p>​        NAT的实现。利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IP地址，源端口号）。同时需要将每对（NAT IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到NAT转换表中，以能替换外来进入内网的IP数据报。</p>
<p>​        NAT主要争议：1.路由器应该只处理第三层功能，不应该对数据段（第四层）进行修改，2.违背了端到端的通信原则，使得应用开发者必须考虑到NAT的存在，如P2P应用，3.地址短缺问题应该由IPv6来解决。</p>
<p>​        NAT穿透问题。外部用户需要访问内网。解决方案：1.静态配置NAT，将特定端口的连接请求转发给服务器（被外部用户请求资源），2.利用UPnP互联网网关设备协议来实现自动配置，可以让服务器自动学习到NAT公共IP地址，能在NAT转换表中，增删端口映射，3.中继，在公共网络上设置中继服务器，让NAT内部的客户与中继服务器建立连接，外部客户也与中继服务器建立连接，中继服务器桥接两个连接的分组。</p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>​        IP数据报出现差错，解决方式是丢弃并发送ICMP进行差错报告。ICMP支持主机或路由器。主要功能是差错（或异常）报告和网络探寻。有两类ICMP报文：差错报告报文（5种，目的不可达，源抑制如路由器缓存已满，超时/超期（TTL），参数问题，重定向即路由器认为应该重新定向到另一个路由器），网络探寻报文（回声请求与应答报文探测网络是否可达，时间戳请求与应答报文）。下图是ICMP报文的编码。</p>
<p><img src="/2019/11/30/network2/1571485984779.png" alt="1571485984779"></p>
<p>​        注意几种不发送ICMP差错报告报文的情况，ICMP差错报告报文（封装在IP数据报里，可能出错）不发送ICMP差错报告报文，除了第一个IP数据分片外，所有后续分片均不发送ICMP差错报告报文，对多播（组播）IP数据报均不发送，对具有特殊地址的IP数据包不发送。并且有些ICMP报文不使用了，信息请求与应答报文，子网掩码请求和应答，路由器询问和通告报文。</p>
<p>​        ICMP报文的格式，ICMP报文封装到IP数据报中传输（作为IP数据报的数据部分），格式如下</p>
<p><img src="/2019/11/30/network2/1571576376063.png" alt="1571576376063"></p>
<p>​        ICMP的校验和是对整个ICMP报文计算。ICMP差错报告报文数据部分的构成：IP数据报首部和IP数据报的数据字段的前8个字节（UDP头和TCP头等）。ICMP的应用实例：Traceroute（用于网络路径跟踪），原理是源主机向目的主机发送一系列的UDP数据报，第$n$组IP数据报设置TTL为$n$（一组一般是3个），目的端口号为不可能使用的端口号，当第$n$组数据报到达第$n$个路由器时，路由器会丢弃数据报并向源主机发送ICMP报文（$type=11$，$code=0$），而ICMP报文携带了路由器名称和IP地址信息，源主机记录ICMP报文和其RTT，并且通过ICMP报文的type的不同判断是否到达目的主机。</p>
<h3 id="IPv6简介"><a href="#IPv6简介" class="headerlink" title="IPv6简介"></a>IPv6简介</h3><p>​        动机：IPv4的地址空间莫的了，改进首部。IPv6数据报格式：固定长度的40字节基本首部，只能源主机分片。路由器一般不处理扩展首部。扩展首部可以是0个也可以是多个，主要定义了6个。</p>
<p><img src="/2019/11/30/network2/1571578311737.png" alt="1571578311737"></p>
<p>​        基本首部，注意有优先级（对应IPv4的TOS），流标签（数据流，根据流标签提供不同的服务），载荷长度（16位，至多64KB），下一个首部（指向下一个扩展首部或传输层协议的首部），跳步限制（TTL）。</p>
<p><img src="/2019/11/30/network2/1571578716571.png" alt="1571578716571"></p>
<p>​        IPv6的改变：检验和，选项的机制，ICMPv6（附加报文类型如Packet Too Big，多播组管理功能来源于IGMP）。IPv6的地址表示，128位比特，16比特一组，划为8组，每组都是十六进制数。其压缩形式，把连续多个0用两个冒号表示。如FF01:0:0:0:0:0:0:43压缩为FF01::43，注意这种压缩在同一个地址中只能使用一次（防止歧义）。IPv4的嵌入形式：0:0:0:0:0:FFFF:13.1.68.3，前80位都是0，然后是16位1，再接32位IPv4地址，（<strong>IPv6两个冒号之间16位，IPv4两个点之间8位</strong>），也可以使用IPv6的压缩。IPv6不再使用掩码，直接使用类似CIDR。在URL中使用中括号括IPv6，再加冒号和端口号，如http://[3FFE::1:800:200C:417A]:8000。    IPv6基本地址类型：单播（一对一通信），多播（一对多通信，只能出现在目的地址中，广播地址被定义为特殊的多播地址），任意播（一对一组之一，只能作为目的地址，通常送到一组接口的最近的接口）。</p>
<p>​        IPv4向IPv6过渡。存在IPv4和IPv6路由器共存的网络。保证共存的技术，隧道（tunneling）技术，IPv6数据报作为IPv4数据报的载荷进行封装，穿越IPv4网络，主机和路由器要支持双协议。</p>
<p>​        注意子网划分后要去掉子网地址和子网广播地址才是可分配地址。主机的IP地址前32位都是固定的，子网掩码是255.255.255.255，到达互联网的路由是缺省路由，描述目的网络IP地址：0.0.0.0，子网掩码0.0.0.0。绝大多数路由表中能聚合一定会聚合。</p>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><p>​        网络抽象为图。顶点集合为N，边集合为E。图的抽象在网络领域应用很广泛，如在P2P中，顶点集合就是peers集合，边集合是TCP连接集合。边有费用（距离），计算的方法根据用途而定，一般是费用越小越好。问题被转化为关键问题：源到目的的最小费用路径是什么。</p>
<p>​        路由算法分类：1.静态路由，手工配置，路由更新慢，优先级高，2.动态路由，路由更新快，可以定期更新，及时响应链路费用或网络拓扑变化。还有以一种（针对动态路由）分类：1.全局信息，所有路由器掌握完整的网络拓扑和链路费用信息，如链路状态（LS）路由算法，在互联网中广泛使用，2.分散信息，路由器只掌握物理相连的邻居以及链路费用。邻居间信息交换，运算的迭代过程，距离向量（DV）路由算法。</p>
<p>​        链路状态路由算法。链路状态路由算法基于Dijkstra算法。如何保证所有结点（路由器）掌握网络拓扑和链路费用？通过“链路状态广播”，发送并收集链路状态分组，类似泛洪法，采用了机制控制泛洪，所有结点拥有相同信息。每个结点（”源“）计算到达所有其他结点的最短路径。经过k次迭代后，得到到达k个目的结点的最短路径。$c(x,y)$表示结点x到结点y链路费用，如果x和y不直接相连则$=\infty$，$D(v)$代表从源到目的v的当前路径费用，$p(v)$沿从源到v的当前路径，v的前序结点，$N’$已经找到最小费用路径的结点集合。下图是算法的过程，其中u是起点。</p>
<p><img src="/2019/11/30/network2/image-20191202160102982.png" alt="image-20191202160102982"></p>
<p>​        u最终得到最短路径树，并记录在路由表中（根据最短路径树记录下一跳）。算法复杂度为$O(n^2)$，更高效的实现为$O(n\log n)$。算法存在震荡的可能，如如果以通信量作为链路费用，那么有可能因为网络中边的费用的变化导致最短路径树变化的太快，一个数据报随着路由器的不断变化的转发而不能到达目的。</p>
<p>​        距离向量路由算法。令$d_x(y)$为从x到y的最短路径的费用，则有</p>
<p><img src="/2019/11/30/network2/image-20191202163323085.png" alt="image-20191202163323085"></p>
<p>​        从上图可以看到结点x要求到y的路径只需要知道x的每个邻居到y的路径的最短距离即可，结点获得最短路径的下一跳，该信息用于转发表中。令$D_x(y)$为从结点x到结点y的最小费用估计，因此每个结点x维护自身的距离向量，每个邻居的费用$c(x,v)$和所有邻居的距离向量就可以计算路由表。核心思想：每个结点不定时地将其自身的DV估计发送给其邻居，当x收到邻居的新的DV估计时更新自身的DV，$D_x(y)$将最终收敛于实际的最小费用$d_x(y)$。</p>
<p>​        距离向量路由算法是异步迭代的，引发每次局部迭代的因素有：1.局部链路费用改变，2.来自邻居的DV更新。距离向量路由算法是分布式算法，邻居在必要时（其DV更新后发生改变）再通告他们的邻居。</p>
<p>​        具体距离向量路由算法中，对于每个结点有三个阶段：1.等待，直到收到本地局部链路费用变化或收到邻居的DV更新，2.重新计算DV估计，3.如果DV中到达任意目的的距离发生改变，通告所有邻居，然后进入第一阶段。下图是一个示例。</p>
<p>​        <img src="/2019/11/30/network2/image-20191202164855267.png" alt="image-20191202164855267"></p>
<p>​        如果链路费用发生改变，距离向量路由算法对改变的响应特点是”好消息传播快“，”坏消息传播慢“（具体例子见MOOC）。有可能产生无穷计数问题。毒性逆转技术用来消除无穷计数问题。毒性逆转技术是：如果一个结点到达某目的结点的最小费用路径是通过某个邻居到达的，则通告给该邻居结点到达该目的的距离为无穷大。<strong>注意毒性逆转不能彻底解决无穷计数问题。</strong>还用于解决无穷计数问题的技术还有最大度量，最大度量定义一个最大的有效费用值，如15跳步，16跳步表示$\infty$，多用于解决物理链路断开的情况，通过设置最大的有效费用值来限制路由器之间无穷计数，如下图所示。还有解决无穷计数问题的技术还有水平分割（和毒性逆转比较像）。</p>
<p><img src="/2019/11/30/network2/image-20191202171314342.png" alt="image-20191202171314342"></p>
<p>​        层次路由。层次路由是一种路由算法或是路由策略。由于将任意规模网络抽象为一个图计算路由——过于理想化，标识所有路由器并且“扁平”网络在实际网络（尤其是大规模网络）中，不可行。考虑到网络规模和管理自治的问题，使用层次路由。聚合路由器为一个区域称为<strong>自治系统</strong>。在同一AS内的路由器运行相同的路由协议（算法）成为自治系统内部路由协议，不同自治系统内的路由器可以运行不同的AS内部路由协议。<strong>网关路由器</strong>用于连接不同的自治系统，网关路由器位于AS“边缘”，通过链路连接其他AS的网关路由器，因此把路由可以分为自治系统间的路由和自治系统内的路由。因此转发表由AS内部路由算法与AS间路由算法共同配置。AS内部路由算法设置AS内部目的网络路由入口，AS内部路由算法与AS间路由算法共同设置AS外部目的网络路由入口。</p>
<p>​        自治系统间路由任务。如果AS内某路由器收到一个目的地址在AS外的数据报，路由器必须知道将该数据报转发给哪个网关路由器，因此AS必须将网络可达性信息传播给AS内部路由器，这些是自治系统间的路由任务。若路由器1d需要将数据报传输给子网x，他将利用AS内部路由信息，确定其到达网关路由器1c的最小费用路径接口并在其路由表中增加入口$(x,l)$。如果一个子网能够通过多个网关路由器到达，则执行<strong>热土豆路由</strong>：将分组发送给最近的网关路由器。热土豆路由如下图所示。</p>
<p><img src="/2019/11/30/network2/image-20191202211530554.png" alt="image-20191202211530554"></p>
<h3 id="Internet路由"><a href="#Internet路由" class="headerlink" title="Internet路由"></a>Internet路由</h3><p>​        Internet采用层次路由。AS内部路由协议也称为内部网络协议IGP。常见的IGP有：路由信息协议RIP，开放最短路径优先协议OSPF，内部网关路由协议IGRP（Cisco私有协议）。</p>
<p>​        RIP协议。1982年随BSD-UNIX操作系统发布。采用距离向量路由算法。距离度量为跳步数，设置最大度量为15跳，16跳为不可达。每隔30秒，邻居自建交换一次DV，称为通告，每次通告最多有25个目的子网（IP地址形式，CIDR形式）。<strong>注意RIP协议的通告形式是由（dest，next，hops）组成</strong>。RIP协议中如果180秒没有收到通告则推断邻居/链路失效，即经过该邻居的路由不可用，将重新计算路由，向邻居发送新的通告，邻居再一次向外发送通告（如果转发表发生改变），其中有可能产生无穷计数问题（但是RIP协议极大程度上消除），RIP协议也采用了毒性逆转，利用通过中next（下一跳）。由于16跳步为不可达，RIP协议则适用于小规模网络。</p>
<p>​        RIP路由表是利用一个称作route-d的应用层进程进行管理。<strong>通过报文周期性地通过UDP数据报发送</strong>（还有其他协议使用TCP协议）。为什么RIP协议是一个网络层协议？<strong>在计算机网络中，我们对一个协议的划分不是根据实现形式划分而是根据协议的功能来划分</strong>。在路由器上也有可能运行应用层（UDP协议，TCP协议）和传输层协议但是是网络层设备，因为实现上层的协议是为完成网络层的功能来实现的。</p>
<p>​        OSPF协议。OSPF协议采用链路状态路由算法。基本原理和链路状态算法相同。采用LS分组扩散（通告），每个路由器构造完整的网络（AS）拓扑图，然后利用Dijkstra算法计算路由。OSPF通告中每个入口对应一个邻居。OSPF通过在整个AS范围内泛洪。<strong>OSPF报文直接封装到IP数据报中</strong>（与RIP协议不同）。与OSPF极其相似的一个路由协议是IS-IS路由协议（中间系统-中间系统协议）。</p>
<p>​        OSPF协议有RIP不具备的优点：1.OSPF协议具有安全性，所有OSPF报文可以被认证，2.允许使用多条相同费用的路径，可以实现流量均衡，3.针对每条链路，针对不同的TOS设置多个不同的费用度量（如卫星链路可以针对“尽力”ToS设置“低”费用，针对实时ToS设置“高”费用），4.集成单播路由和多播路由的集成，多播OSPF协议（MOSPF）与OSPF利用相同的网络拓扑数据，<strong>5.OSPF支持大规模AS分层（最重要）</strong>。</p>
<p><img src="/2019/11/30/network2/image-20191202222833424.png" alt="image-20191202222833424"></p>
<p>​        注意主干区和局部区交集的路由器被称为区边界路由器（ABR）。区边界路由器汇总所在区的网络的距离信息通告给其他区边界路由器。主干路由器（BR），在主干区内运行OSPF路由算法。AS边界路由器（ASBR），连接其他AS，一个AS可以有多个ASBR。</p>
<p>​        Internet网络AS间采用边界网关协议（BGP协议）。BGP是事实上的标准域间路由协议，目前正在使用BGP4。BGP为每个AS提供了一种手段。eBGP也称外部BGP，iBGP也称内部BGP。</p>
<p><img src="/2019/11/30/network2/image-20191202224213126.png" alt="image-20191202224213126"></p>
<p>​        BGP会话：两个BGP路由器（“Peers”）交换BGP报文。BGP会话主要是通告去往不同目的前缀（这里前缀也指子网）的路径（因此也称BGP为”路径向量“协议，与距离向量不同，这里通告的是完整的自治系统路径的信息），BGP会话报文交换基于半永久的TCP连接。跨越AS之间的BGP会话称为外部会话，AS内部的会话称为内部会话。</p>
<p>​        BGP报文：1.OPEN报文，与peer建立TCP连接，并认证发送方，2.UPDATE，通告新路径，或撤销原路径，3.KEEPALIVE，保活连接，也用于对OPEN请求的认确，4.NOTIFICATION，报告先前报文的差错，也被用于关闭连接。<strong>AS通告一个前缀给另一个AS时会尽量聚合网络前缀</strong>。下图是BGP报文运用的一个例子。</p>
<p><img src="/2019/11/30/network2/image-20191202225350563.png" alt="image-20191202225350563"></p>
<p>​        BGP报文的内容。通告的前缀信息也包括BGP属性，前缀+属性等于“路由”。有两个重要属性：1.AS-PATH（AS路径），包含前缀通告所经过的AS序列，2.NEXT-HOP（下一跳），开始一个AS-PATH的<strong>路由器接口</strong>，指向下一跳AS。注意有可能AS-PATH相同但NEXT-HOP不同，如下图的2b和2c，此时将根据热土豆路由来确定。</p>
<p><img src="/2019/11/30/network2/image-20191202230059284.png" alt="image-20191202230059284"></p>
<p>​        网关路由器手动路由通告后，利用其输入策略决策接收/拒绝该路由（有可能从不将流量路由到AS x），这是基于策略路由。当网关路由器获知到达某目的AS的多条路由时，基于以下准则选择（优先级）：1.本地偏好值属性，策略决策，2.最短AS-PATH，这里最短的定义为AS数最少，3.最近NEXT-HOP路由器，热土豆路由，4.附加准则。</p>
<p>​        下图是BGP路由选择策略的一个例子。桩网络由于比较特殊，通常使用静态配置即可。存在多宿网络。客户网络一般都不提供过路流量的传输（即流量的目的不是这个网络），一般只有提供商网络提供过路流量的传输。因此Internet网络中AS也分桩AS（stub AS）和多宿AS，多宿AS再分为<strong>提供过路流量传输的网络</strong>和<strong>不提供过路流量传输的网络</strong>。</p>
<p><img src="/2019/11/30/network2/image-20191202232043991.png" alt="image-20191202232043991"></p>
<p>​        其中提供商的网络遵循只希望为其客户提供路由的规则。如下图所示。</p>
<p><img src="/2019/11/30/network2/image-20191202232551918.png" alt="image-20191202232551918"></p>
<p>​        为什么采用不同的AS内与AS间路由协议？1.策略，AS间期望能够管理控制流量如何被路由，谁路由经过其网络等，AS内则是单一管理，无需策略决策，2.规模，层次路由节省路由表大小，减少路由更新流量，适应大规模互联网，3.性能，AS内是侧重性能，AS间是策略主导。</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://1170300229.github.io/2019/11/30/network2/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://1170300229.github.io/2019/11/30/network2/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
